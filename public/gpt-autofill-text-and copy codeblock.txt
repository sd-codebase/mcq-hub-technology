

(async function() {
  let processInProgress = false;
  // remove previous if exists
  document.getElementById('pasteBtn')?.remove();

  // Auto-trigger paste+send when tab becomes active again
  window.addEventListener("focus", async () => {
    console.log("ðŸ”™ User returned to tab â†’ auto-trigger paste+send");
    if(processInProgress) {
      return false;
    }
    try {
      text = await navigator.clipboard.readText();
      
      if (!text) {
        return;
      }
      console.log("hasText")
      if(text.includes("\n**Count:**") && text.includes("\n**Subject:**") && text.includes("\n**Chapter:**")) {
       pasteAndSend();  // <-- your main workflow function
      }
    } catch {
      text = prompt("Clipboard blocked â€” paste text here:");
      if (!text) return;
    }
      
  });


  // create button
  const btn = document.createElement('button');
  btn.id = 'pasteBtn';
  btn.textContent = 'ðŸ“‹ Paste+AutoSend';
  Object.assign(btn.style, {
    position: 'fixed',
    right: '10px',
    bottom: '120px',
    zIndex: '2147483647',
    padding: '10px 14px',
    borderRadius: '8px',
    background: '#0ea37a',
    color: '#fff',
    border: 'none',
    cursor: 'pointer',
    boxShadow: '0 6px 18px rgba(0,0,0,0.25)',
    fontWeight: '600'
  });
  document.body.appendChild(btn);

  function showSuccessToast(message = "Code copied successfully!") {
    // ------- SOUND -------
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";
    osc.frequency.value = 880;      // pleasant ding
    gain.gain.setValueAtTime(0.2, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.4);
  } catch (e) {
    console.warn("Audio playback blocked by browser:", e);
  }
  const toast = document.createElement("div");
  toast.textContent = message;

  Object.assign(toast.style, {
    position: "fixed",
    top: "40px",
    right: "40px",
    background: "#10a37f",
    color: "white",
    padding: "64px 64px",
    borderRadius: "8px",
    fontSize: "20px",
    fontWeight: "600",
    zIndex: "999999999",
    boxShadow: "0 6px 18px rgba(0,0,0,0.25)",
    opacity: "0",
    transition: "opacity 0.3s ease",
  });

  document.body.appendChild(toast);

  // Fade in
  requestAnimationFrame(() => {
    toast.style.opacity = "1";
  });

  // Fade out and remove
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), 500);
  }, 5000);
}

  // helper: wait until ChatGPT stops generating
  function waitForGPTToFinish() {
    return new Promise(resolve => {
      const interval = setInterval(() => {
        // UI markers for "Generating" state
        const isGeneratingStopped =
          document.querySelector('[aria-label="Start voice mode"]');
          

        if (isGeneratingStopped) {
          clearInterval(interval);
          setTimeout(resolve, 1000)
        }
      }, 3000);
    });
  }

  // find latest code block
  function getLatestCodeBlock() {
    const blocks = [...document.querySelectorAll("pre code")];
    if (!blocks.length) return null;
    return blocks[blocks.length - 1].innerText;
  }

  // paste logic
  async function pasteAndSend() {
    let text = "";
    try {
      text = await navigator.clipboard.readText();
      if (!text) {
        alert("Clipboard empty.");
        return;
      }
    } catch {
      text = prompt("Clipboard blocked â€” paste text here:");
      if (!text) return;
    }

    // contentEditable or textarea
    const editable =
      document.querySelector('[contenteditable="true"]') ||
      document.querySelector('[role="textbox"]') ||
      document.querySelector('textarea[name="prompt-textarea"]') ||
      document.querySelector("textarea");

    if (!editable) {
      alert("ChatGPT input box not found!");
      return;
    }

    // insert text
    editable.focus();
    const ok = document.execCommand("insertText", false, text);
    if (!ok) {
      editable.innerText += text;
    }

    editable.dispatchEvent(new InputEvent("input", { bubbles: true }));

    // update button state
    btn.textContent = "âœ… Pasted";
    

    // auto-send after 200ms
    setTimeout(async () => {
      const sendBtn =
        document.querySelector('button[data-testid="send-button"]') ||
        document.querySelector('button[aria-label="Send message"]') ||
        document.querySelector('button[type=submit]');

      if (sendBtn) {
        sendBtn.click();
        console.log("ðŸš€ Auto-sent message.");
        processInProgress = true;
      } else {
        console.warn("âŒ Send button not found.");
      }

      // Wait until model finishes responding
      console.log("âŒ› Waiting for GPT to finish...");
      await waitForGPTToFinish();
      console.log("âœ… GPT stopped responding.");

      // Get latest code block
      const code = getLatestCodeBlock();
      if (code) {
        await navigator.clipboard.writeText(code);
        showSuccessToast("Latest code block copied!");
        console.log("ðŸ“‹ Copied latest code block to clipboard.");
        btn.textContent = "âœ¨ Code Copied!";
        processInProgress = false;
      } else {
        console.warn("âš ï¸ No code block found.");
        btn.textContent = "âš ï¸ No Code";
      }

      // reset button text
      setTimeout(() => {
        btn.textContent = "ðŸ“‹ Paste+AutoSend";
      }, 1200);

    }, 200);
  }

  btn.addEventListener("click", pasteAndSend);

  console.log("Paste+AutoSend+AutoCopy button added.");
})();
