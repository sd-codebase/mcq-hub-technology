{
  "interview_questions": [
    {
      "id": "interview-001-01-001",
      "question": "What are the primitive types in TypeScript and how do they differ from JavaScript?",
      "answer": "## Primitive Types in TypeScript\n\nTypeScript has the following primitive types:\n\n### Basic Primitive Types\n1. **string** - text data\n2. **number** - integers and floating-point numbers\n3. **boolean** - true/false values\n4. **null** - intentional absence of value\n5. **undefined** - uninitialized value\n6. **symbol** - unique identifiers (ES6)\n7. **bigint** - large integers (ES2020)\n\n```typescript\nlet name: string = \"Alice\";\nlet age: number = 30;\nlet isActive: boolean = true;\nlet empty: null = null;\nlet notAssigned: undefined = undefined;\nlet id: symbol = Symbol(\"id\");\nlet bigNumber: bigint = 9007199254740991n;\n```\n\n### Key Differences from JavaScript\n\n**1. Type Annotations**\n```typescript\n// TypeScript - explicit typing\nlet count: number = 10;\n\n// JavaScript - no type annotations\nlet count = 10;\n```\n\n**2. Compile-time Type Checking**\n```typescript\nlet age: number = 25;\nage = \"twenty-five\"; // ‚ùå Error: Type 'string' is not assignable to type 'number'\n```\n\n**3. Lowercase vs Uppercase**\n```typescript\nlet name: string = \"John\"; // ‚úÖ Correct - primitive type\nlet name: String = \"John\"; // ‚ùå Avoid - object wrapper type\n```",
      "explanation": "TypeScript adds **static type checking** on top of JavaScript's primitive types. This catches type errors at compile time rather than runtime, making code more robust and maintainable."
    },
    {
      "id": "interview-001-01-002",
      "question": "What is the difference between null and undefined in TypeScript?",
      "answer": "## null vs undefined\n\n### Conceptual Difference\n\n- **undefined** - Variable declared but not initialized, or property doesn't exist\n- **null** - Intentional absence of value, explicitly assigned\n\n### Examples\n\n```typescript\n// undefined - not initialized\nlet x: number;\nconsole.log(x); // undefined\n\n// null - intentionally empty\nlet user: string | null = null;\n```\n\n### Type System Differences\n\n**1. Without strictNullChecks**\n```typescript\nlet name: string = null; // ‚úÖ Allowed\nlet age: number = undefined; // ‚úÖ Allowed\n```\n\n**2. With strictNullChecks** (recommended)\n```typescript\nlet name: string = null; // ‚ùå Error\nlet name: string | null = null; // ‚úÖ Correct\n\nlet age: number = undefined; // ‚ùå Error\nlet age: number | undefined = undefined; // ‚úÖ Correct\n```\n\n### typeof Behavior\n\n```typescript\nconsole.log(typeof null); // \"object\" (JavaScript quirk!)\nconsole.log(typeof undefined); // \"undefined\"\n```\n\n### Equality Comparisons\n\n```typescript\nnull == undefined;  // true (loose equality)\nnull === undefined; // false (strict equality)\n\nnull == null;  // true\nnull === null; // true\n```\n\n### Best Practices\n\n```typescript\n// Use undefined for uninitialized\nlet value: string | undefined;\n\n// Use null for intentionally empty\nlet selectedUser: User | null = null;\n\n// Optional parameters use undefined\nfunction greet(name?: string) {\n  // name is string | undefined\n}\n```",
      "explanation": "Understanding the distinction is **crucial for strict type checking**. `undefined` typically means \"not yet set\", while `null` means \"intentionally empty\". Always use `strictNullChecks` in production code."
    },
    {
      "id": "interview-001-01-003",
      "question": "Why should you use lowercase primitive types (string, number, boolean) instead of uppercase (String, Number, Boolean)?",
      "answer": "## Lowercase vs Uppercase Types\n\n### The Difference\n\n```typescript\n// Lowercase - primitive types (‚úÖ USE THESE)\nlet name: string = \"John\";\nlet age: number = 30;\nlet active: boolean = true;\n\n// Uppercase - object wrapper types (‚ùå AVOID)\nlet name: String = \"John\";\nlet age: Number = 30;\nlet active: Boolean = true;\n```\n\n### What Are Object Wrappers?\n\n```typescript\n// Primitive (what you almost always want)\nlet primitiveStr: string = \"hello\";\n\n// Object wrapper (rarely needed)\nlet objectStr: String = new String(\"hello\");\n\nconsole.log(typeof primitiveStr); // \"string\"\nconsole.log(typeof objectStr);    // \"object\"\n```\n\n### Problems with Uppercase Types\n\n**1. Type Compatibility Issues**\n```typescript\nlet str1: string = \"hello\";\nlet str2: String = \"world\";\n\nstr1 = str2; // ‚ùå Error: Type 'String' is not assignable to type 'string'\nstr2 = str1; // ‚úÖ OK: string is assignable to String\n```\n\n**2. Unexpected Behavior**\n```typescript\nlet bool1: Boolean = new Boolean(false);\nif (bool1) {\n  console.log(\"This runs!\"); // üò± Object is truthy even though value is false\n}\n\nlet bool2: boolean = false;\nif (bool2) {\n  console.log(\"This doesn't run\"); // ‚úÖ Expected behavior\n}\n```\n\n**3. Performance Overhead**\n```typescript\n// Primitive - direct value (fast)\nlet x: number = 42;\n\n// Object wrapper - creates object (slower)\nlet y: Number = new Number(42);\n```\n\n### TypeScript Official Recommendation\n\n```typescript\n// ‚úÖ DO use lowercase\nfunction getName(): string { return \"Alice\"; }\nlet count: number = 10;\nlet flag: boolean = true;\n\n// ‚ùå DON'T use uppercase\nfunction getName(): String { return \"Alice\"; }\nlet count: Number = 10;\nlet flag: Boolean = true;\n```",
      "explanation": "**Always use lowercase primitive types** in TypeScript. The uppercase versions refer to JavaScript object wrappers and can cause confusing bugs. This is one of the most important conventions in TypeScript."
    },
    {
      "id": "interview-001-01-004",
      "question": "What is strictNullChecks and why is it important?",
      "answer": "## strictNullChecks\n\n### What It Does\n\n`strictNullChecks` is a TypeScript compiler option that prevents `null` and `undefined` from being assigned to any type unless explicitly allowed.\n\n### Configuration\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strictNullChecks\": true  // Enable strict null checking\n  }\n}\n```\n\n### Without strictNullChecks (default in old projects)\n\n```typescript\nlet name: string = null; // ‚úÖ Allowed (dangerous!)\nlet age: number = undefined; // ‚úÖ Allowed (dangerous!)\n\nfunction getLength(s: string) {\n  return s.length; // Runtime error if s is null!\n}\n\ngetLength(null); // Compiles but crashes at runtime üò±\n```\n\n### With strictNullChecks (recommended)\n\n```typescript\nlet name: string = null; // ‚ùå Error: Type 'null' is not assignable to type 'string'\nlet name: string | null = null; // ‚úÖ Must explicitly allow null\n\nlet age: number = undefined; // ‚ùå Error\nlet age: number | undefined = undefined; // ‚úÖ Explicit\n\nfunction getLength(s: string) {\n  return s.length; // Safe - s cannot be null\n}\n\ngetLength(null); // ‚ùå Compile error - caught early!\n```\n\n### Handling Nullable Values\n\n**1. Type Guards**\n```typescript\nfunction printLength(s: string | null) {\n  if (s !== null) {\n    console.log(s.length); // ‚úÖ Safe - TypeScript knows s is string\n  }\n}\n```\n\n**2. Optional Chaining**\n```typescript\ninterface User {\n  name: string;\n  address?: { street: string };\n}\n\nconst user: User | null = getUser();\nconsole.log(user?.address?.street); // Safe access\n```\n\n**3. Nullish Coalescing**\n```typescript\nlet name: string | null = null;\nlet displayName = name ?? \"Anonymous\"; // \"Anonymous\"\n```\n\n**4. Non-null Assertion** (use sparingly)\n```typescript\nlet name: string | null = getName();\nconsole.log(name!.length); // ! tells TS \"trust me, it's not null\"\n```\n\n### Benefits\n\n‚úÖ **Catch null/undefined errors at compile time**  \n‚úÖ **More explicit about nullable values**  \n‚úÖ **Better IDE support and autocomplete**  \n‚úÖ **Prevents billion-dollar mistakes**  \n‚úÖ **Self-documenting code**",
      "explanation": "Tony Hoare called null his \"billion-dollar mistake\". `strictNullChecks` helps prevent null reference errors, which are among the **most common runtime errors** in programming. Always enable it in new projects!"
    },
    {
      "id": "interview-001-01-005",
      "question": "How does TypeScript handle the number type differently from other languages?",
      "answer": "## TypeScript's number Type\n\n### Single Number Type\n\nUnlike many languages, TypeScript (and JavaScript) has **only one number type** for all numeric values:\n\n```typescript\nlet integer: number = 42;\nlet float: number = 3.14;\nlet hex: number = 0xFF;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet negative: number = -100;\n```\n\n### Special Numeric Values\n\n```typescript\nlet infinity: number = Infinity;\nlet negInfinity: number = -Infinity;\nlet notANumber: number = NaN;\n\n// All are valid number types!\nconsole.log(typeof Infinity); // \"number\"\nconsole.log(typeof NaN);      // \"number\" (despite the name!)\n```\n\n### Comparison with Other Languages\n\n```typescript\n// TypeScript/JavaScript - ONE type\nlet x: number = 10;\nlet y: number = 10.5;\n\n// Java - Multiple types\nint x = 10;        // 32-bit integer\nlong z = 100L;     // 64-bit integer  \nfloat y = 10.5f;   // 32-bit float\ndouble w = 10.5;   // 64-bit float\n\n// C# - Multiple types\nint x = 10;\nlong z = 100L;\nfloat y = 10.5f;\ndouble w = 10.5;\ndecimal m = 10.5m;\n```\n\n### Limitations\n\n**1. Precision Issues**\n```typescript\nconsole.log(0.1 + 0.2); // 0.30000000000000004 üò±\nconsole.log(0.1 + 0.2 === 0.3); // false\n\n// Solution: Use epsilon comparison\nconst EPSILON = Number.EPSILON;\nfunction areEqual(a: number, b: number): boolean {\n  return Math.abs(a - b) < EPSILON;\n}\n```\n\n**2. Integer Limits**\n```typescript\n// Safe integer range\nconsole.log(Number.MAX_SAFE_INTEGER); // 9007199254740991\nconsole.log(Number.MIN_SAFE_INTEGER); // -9007199254740991\n\nlet big: number = 9007199254740992;\nconsole.log(big + 1 === big + 2); // true üò± Loss of precision!\n```\n\n### Solution: BigInt for Large Integers\n\n```typescript\n// For integers larger than MAX_SAFE_INTEGER\nlet huge: bigint = 9007199254740991n;\nlet bigger: bigint = huge + 1n; // Works correctly!\n\n// Cannot mix number and bigint\nlet x: number = 10;\nlet y: bigint = 20n;\n// let z = x + y; // ‚ùå Error: Cannot mix types\nlet z = x + Number(y); // ‚úÖ Convert first\n```\n\n### Type Narrowing with Numbers\n\n```typescript\nfunction processValue(val: number | string) {\n  if (typeof val === \"number\") {\n    // TypeScript knows val is number here\n    console.log(val.toFixed(2));\n  } else {\n    // TypeScript knows val is string here\n    console.log(val.toUpperCase());\n  }\n}\n```",
      "explanation": "TypeScript's single `number` type is **simpler but less precise** than statically-typed languages. For financial calculations or large integers, be aware of precision issues and consider using libraries like decimal.js or the native `bigint` type."
    },
    {
      "id": "interview-001-01-006",
      "question": "What are the gotchas with boolean type in TypeScript?",
      "answer": "## Boolean Type Gotchas\n\n### 1. Truthy vs Falsy Values\n\nTypeScript's boolean type only accepts `true` or `false`, but JavaScript has truthy/falsy conversion:\n\n```typescript\n// Type system: only true/false\nlet flag: boolean = true; // ‚úÖ\nlet flag: boolean = false; // ‚úÖ\nlet flag: boolean = 1; // ‚ùå Error\nlet flag: boolean = \"yes\"; // ‚ùå Error\n\n// Runtime: truthy/falsy conversion\nif (\"hello\") { } // Works - \"hello\" is truthy\nif (0) { } // Works - 0 is falsy\nif ([]) { } // Works - [] is truthy\n```\n\n### 2. Falsy Values in JavaScript\n\n```typescript\n// All falsy values (convert to false in boolean context)\nlet values = [\n  false,\n  0,\n  -0,\n  0n,        // BigInt zero\n  \"\",        // empty string\n  null,\n  undefined,\n  NaN\n];\n\nvalues.forEach(v => {\n  if (!v) console.log(`${v} is falsy`);\n});\n```\n\n### 3. Boolean() Constructor Trap\n\n```typescript\n// Primitive boolean (correct)\nlet bool1: boolean = false;\nif (!bool1) {\n  console.log(\"Works as expected\"); // ‚úÖ\n}\n\n// Boolean object (dangerous!)\nlet bool2 = new Boolean(false);\nif (bool2) {\n  console.log(\"This runs!\"); // üò± Object is always truthy\n}\n\nconsole.log(typeof bool1); // \"boolean\"\nconsole.log(typeof bool2); // \"object\"\n```\n\n### 4. Explicit Boolean Conversion\n\n```typescript\n// Using Boolean() function (not constructor)\nlet str = \"hello\";\nlet bool: boolean = Boolean(str); // true\n\n// Using double negation (common pattern)\nlet bool2: boolean = !!str; // true\n\n// Type-safe conversion\nfunction toBoolean(value: unknown): boolean {\n  return !!value;\n}\n```\n\n### 5. Comparison Gotchas\n\n```typescript\n// String comparison doesn't give boolean in union\nlet result = \"5\" > \"10\"; // boolean (true, lexicographic comparison)\nlet typedResult: boolean = \"5\" > \"10\"; // ‚úÖ Works\n\n// Null/undefined comparisons\nconsole.log(null == false);      // false\nconsole.log(undefined == false); // false\nconsole.log(null == undefined);  // true (!)\n```\n\n### 6. Array/Object Truthiness\n\n```typescript\n// Empty array/object are truthy!\nif ([]) {\n  console.log(\"Empty array is truthy!\"); // Runs!\n}\n\nif ({}) {\n  console.log(\"Empty object is truthy!\"); // Runs!\n}\n\n// Check length/keys instead\nlet arr: number[] = [];\nif (arr.length > 0) { } // ‚úÖ Correct check\n\nlet obj: Record<string, any> = {};\nif (Object.keys(obj).length > 0) { } // ‚úÖ Correct check\n```\n\n### 7. Strict Boolean Check\n\n```typescript\n// Type guard for strict boolean check\nfunction isBoolean(value: unknown): value is boolean {\n  return typeof value === \"boolean\";\n}\n\n// Usage\nlet value: unknown = \"true\";\nif (isBoolean(value)) {\n  // TypeScript knows value is boolean here\n  console.log(value ? \"yes\" : \"no\");\n}\n```\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use boolean type\nlet isActive: boolean = true;\n\n// ‚úÖ DO: Use explicit conversion when needed\nlet hasValue: boolean = !!maybeNull;\n\n// ‚úÖ DO: Check specific conditions\nif (array.length > 0) { }\nif (str !== \"\") { }\n\n// ‚ùå DON'T: Rely on truthy/falsy for important logic\nif (value) { } // What if value is 0 or \"\"?\n\n// ‚ùå DON'T: Use Boolean constructor\nlet bool = new Boolean(false); // Creates object!\n```",
      "explanation": "The boolean type seems simple but has **many edge cases** due to JavaScript's truthy/falsy coercion. Always be explicit about what you're checking to avoid subtle bugs."
    },
    {
      "id": "interview-001-01-007",
      "question": "How do you handle variables that might be null or undefined in TypeScript?",
      "answer": "## Handling Nullable Values\n\n### 1. Union Types (Explicit Nullability)\n\n```typescript\n// Declare nullable types explicitly\nlet name: string | null = null;\nlet age: number | undefined = undefined;\nlet data: string | null | undefined;\n```\n\n### 2. Optional Properties\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email?: string;  // email is string | undefined\n  phone: string | null;  // explicitly nullable\n}\n\nconst user: User = {\n  id: 1,\n  name: \"Alice\"\n  // email is optional, phone must be set to null if absent\n};\n```\n\n### 3. Type Guards (Narrowing)\n\n```typescript\nfunction printLength(str: string | null) {\n  // Check before use\n  if (str !== null) {\n    console.log(str.length); // ‚úÖ TypeScript knows str is string\n  }\n}\n\n// Truthy check (be careful!)\nfunction process(value: string | null | undefined) {\n  if (value) {\n    // value is string (not null, not undefined, not \"\")\n    console.log(value.toUpperCase());\n  }\n}\n```\n\n### 4. Optional Chaining (?.)\n\n```typescript\ninterface Address {\n  street: string;\n  city?: string;\n}\n\ninterface User {\n  name: string;\n  address?: Address;\n}\n\nconst user: User | null = getUser();\n\n// Safe access through optional chain\nconst city = user?.address?.city; // string | undefined\n\n// Also works with arrays and functions\nconst firstItem = array?.[0];\nconst result = obj.method?.();\n```\n\n### 5. Nullish Coalescing (??)\n\n```typescript\n// Provide default for null/undefined only\nlet name: string | null = null;\nlet displayName = name ?? \"Guest\"; // \"Guest\"\n\nlet count: number | undefined = 0;\nlet display = count ?? 10; // 0 (not 10!)\n\n// Compare with OR operator\nlet display2 = count || 10; // 10 (treats 0 as falsy!)\n\n// ?? only checks null/undefined\n// || checks all falsy values (0, \"\", false, null, undefined, NaN)\n```\n\n### 6. Non-null Assertion (!)\n\n```typescript\n// Tell TypeScript \"trust me, it's not null\"\nlet name: string | null = getName();\nconsole.log(name!.length); // ! removes null from type\n\n// ‚ö†Ô∏è Use sparingly - you're bypassing type safety!\n// Only use when you're 100% sure it's not null\n\n// Better approach - use type guard\nif (name !== null) {\n  console.log(name.length); // ‚úÖ Type-safe\n}\n```\n\n### 7. Default Parameters\n\n```typescript\n// Function parameters with defaults\nfunction greet(name?: string) {\n  // name is string | undefined\n  const safeName = name ?? \"Guest\";\n  console.log(`Hello, ${safeName}`);\n}\n\n// Or use default parameter\nfunction greet2(name: string = \"Guest\") {\n  // name is always string\n  console.log(`Hello, ${name}`);\n}\n```\n\n### 8. Type Assertion (as)\n\n```typescript\n// When you know more than TypeScript\nlet value: unknown = \"hello\";\nlet length = (value as string).length; // ‚ö†Ô∏è Unsafe if wrong\n\n// Better - use type guard\nif (typeof value === \"string\") {\n  let length = value.length; // ‚úÖ Safe\n}\n```\n\n### 9. Definite Assignment Assertion\n\n```typescript\nclass Component {\n  // Compiler doesn't know init() will be called\n  element!: HTMLElement; // ! says \"trust me, it will be assigned\"\n  \n  constructor() {\n    this.init();\n  }\n  \n  init() {\n    this.element = document.createElement(\"div\");\n  }\n}\n```\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use optional chaining for deep access\nconst street = user?.address?.street;\n\n// ‚úÖ DO: Use nullish coalescing for defaults\nconst name = user?.name ?? \"Anonymous\";\n\n// ‚úÖ DO: Use type guards for complex logic\nif (user !== null && user.age > 18) { }\n\n// ‚ùå DON'T: Overuse non-null assertion\nuser!.name; // Dangerous if user is actually null\n\n// ‚ùå DON'T: Mix up || and ??\nconst count = value || 10; // Wrong if value can be 0\nconst count = value ?? 10; // Correct\n```",
      "explanation": "Modern TypeScript provides **powerful tools** for null safety. Optional chaining and nullish coalescing make code more concise and safer. Always prefer type guards over assertions for production code."
    },
    {
      "id": "interview-001-01-008",
      "question": "What is type inference and how does it work with basic types?",
      "answer": "## Type Inference\n\n### What is Type Inference?\n\nTypeScript automatically determines types based on values, reducing the need for explicit annotations.\n\n### Basic Type Inference\n\n```typescript\n// TypeScript infers types from initialization\nlet name = \"Alice\";        // inferred as string\nlet age = 30;              // inferred as number\nlet isActive = true;       // inferred as boolean\nlet empty = null;          // inferred as null\nlet notSet = undefined;    // inferred as undefined\n\n// No need for explicit annotation\nlet name: string = \"Alice\"; // Redundant but valid\n```\n\n### Literal Type Inference\n\n```typescript\n// const creates literal types\nconst name = \"Alice\";  // type: \"Alice\" (literal, not string)\nconst age = 30;        // type: 30 (literal, not number)\nconst flag = true;     // type: true (literal, not boolean)\n\n// let creates general types\nlet name2 = \"Alice\";   // type: string\nlet age2 = 30;         // type: number\nlet flag2 = true;      // type: boolean\n```\n\n### Best Common Type\n\n```typescript\n// Infers union of all types\nlet mixed = [1, \"hello\", true];  // (string | number | boolean)[]\n\nlet numbers = [1, 2, 3];         // number[]\nlet strings = [\"a\", \"b\"];        // string[]\n\n// With null/undefined\nlet values = [1, null];          // (number | null)[]\n```\n\n### Contextual Typing\n\n```typescript\n// Type inferred from context\nwindow.addEventListener(\"click\", (e) => {\n  // e is inferred as MouseEvent\n  console.log(e.clientX);\n});\n\n// Array methods\nconst numbers = [1, 2, 3];\nconst doubled = numbers.map(n => n * 2);\n// n is inferred as number, doubled as number[]\n```\n\n### Function Return Type Inference\n\n```typescript\n// Return type inferred from return statement\nfunction add(a: number, b: number) {\n  return a + b; // inferred as number\n}\n\nfunction greet(name: string) {\n  return `Hello, ${name}`; // inferred as string\n}\n\nfunction process(flag: boolean) {\n  if (flag) {\n    return 42;      // number\n  } else {\n    return \"error\"; // string\n  }\n  // return type inferred as number | string\n}\n```\n\n### When Inference Fails\n\n```typescript\n// Declared without initialization - inferred as any\nlet value;              // type: any\nvalue = \"hello\";        // still any\nvalue = 42;             // still any\n\n// Better - provide type annotation\nlet value: string;      // type: string\nvalue = \"hello\";        // ‚úÖ\nvalue = 42;             // ‚ùå Error\n```\n\n### Widening\n\n```typescript\n// null/undefined widen to any without strictNullChecks\nlet x = null;           // type: any (without strict mode)\nlet x = null;           // type: null (with strict mode)\n\n// Prevent widening with const assertion\nlet obj = { name: \"Alice\" };\n// obj.name is string (widened)\n\nlet obj2 = { name: \"Alice\" } as const;\n// obj2.name is \"Alice\" (literal, readonly)\n```\n\n### Type Inference Best Practices\n\n```typescript\n// ‚úÖ DO: Let TypeScript infer obvious types\nlet count = 0;                    // Clear: number\nlet items = [1, 2, 3];           // Clear: number[]\n\n// ‚úÖ DO: Annotate when inference is unclear\nlet data: string | null = null;  // Explicit intent\n\n// ‚úÖ DO: Annotate function parameters\nfunction process(value: string) {  // Required\n  return value.length;             // Return type inferred\n}\n\n// ‚úÖ DO: Annotate complex return types\nfunction getData(): Promise<User[]> {  // Clear intent\n  return fetchUsers();\n}\n\n// ‚ùå DON'T: Over-annotate obvious types\nlet name: string = \"Alice\";  // Redundant\nlet count: number = 0;       // Redundant\n\n// ‚ùå DON'T: Rely on inference for public APIs\nexport function process(data) {  // Bad: implicit any\n  return data.value;             // Unclear\n}\n\n// ‚úÖ Better\nexport function process(data: Config): string {\n  return data.value;\n}\n```\n\n### Inference with Union Types\n\n```typescript\nfunction getValue(useDefault: boolean) {\n  if (useDefault) {\n    return \"default\";\n  }\n  return 42;\n}\n// Inferred: (useDefault: boolean) => string | number\n\nlet result = getValue(true);\n// result type: string | number\n```",
      "explanation": "Type inference is one of TypeScript's **most powerful features**. It provides type safety without verbose annotations. However, explicit types for function parameters and complex return types improve code clarity and catch errors earlier."
    },
    {
      "id": "interview-001-01-009",
      "question": "What are the differences between string, String, and template literals in TypeScript?",
      "answer": "## String Types in TypeScript\n\n### 1. Primitive string Type (Lowercase)\n\n```typescript\n// Primitive string type - USE THIS\nlet name: string = \"Alice\";\nlet greeting: string = 'Hello';\nlet template: string = `Hi ${name}`;\n\n// This is what you want 99% of the time\n```\n\n### 2. String Object Wrapper (Uppercase)\n\n```typescript\n// String object wrapper - AVOID THIS\nlet name: String = new String(\"Alice\");\nlet name2: String = \"Alice\"; // Also matches String type\n\nconsole.log(typeof name);  // \"object\" üò±\nconsole.log(typeof name2); // \"string\" ‚úÖ\n\n// Problems with String type\nlet primitiveStr: string = \"hello\";\nlet objectStr: String = \"world\";\n\nprimitiveStr = objectStr; // ‚ùå Error\nobjectStr = primitiveStr; // ‚úÖ Works (but shouldn't use String)\n```\n\n### 3. Template Literals (Template Strings)\n\n```typescript\n// Runtime: Template literals for string interpolation\nlet name = \"Alice\";\nlet age = 30;\nlet message = `Hello, ${name}! You are ${age} years old.`;\n\n// Can include expressions\nlet math = `2 + 2 = ${2 + 2}`; // \"2 + 2 = 4\"\n\n// Multi-line strings\nlet multiline = `\n  Line 1\n  Line 2\n  Line 3\n`;\n```\n\n### 4. Template Literal Types (Type System)\n\n```typescript\n// Template literal TYPES - powerful type-level feature\ntype Greeting = `Hello, ${string}`;\n\nlet valid: Greeting = \"Hello, World\";     // ‚úÖ\nlet invalid: Greeting = \"Hi, World\";      // ‚ùå Error\n\n// With literal unions\ntype Color = \"red\" | \"blue\" | \"green\";\ntype ColorClass = `bg-${Color}`;  // \"bg-red\" | \"bg-blue\" | \"bg-green\"\n\nlet className: ColorClass = \"bg-red\";     // ‚úÖ\nlet invalid: ColorClass = \"bg-yellow\";    // ‚ùå Error\n\n// Combining multiple parts\ntype HTTPMethod = \"GET\" | \"POST\";\ntype Endpoint = \"users\" | \"posts\";\ntype Route = `/${Endpoint}`;\ntype APICall = `${HTTPMethod} ${Route}`;\n// Result: \"GET /users\" | \"GET /posts\" | \"POST /users\" | \"POST /posts\"\n```\n\n### Comparison Table\n\n| Feature | string (primitive) | String (wrapper) | Template Literal | Template Literal Type |\n|---------|-------------------|------------------|------------------|----------------------|\n| Usage | Runtime value type | Object wrapper | Runtime string syntax | Compile-time type |\n| Syntax | `string` | `String` | \\`text ${expr}\\` | \\`prefix-${Type}\\` |\n| Recommended | ‚úÖ YES | ‚ùå NO | ‚úÖ YES | ‚úÖ YES |\n| Example | `let x: string` | `let x: String` | `let x = \\`Hi ${n}\\`` | `type T = \\`id-${string}\\`` |\n\n### Practical Examples\n\n```typescript\n// ‚úÖ CORRECT: Using primitive string\nfunction greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\n// ‚ùå WRONG: Using String wrapper\nfunction greet(name: String): String {\n  return `Hello, ${name}`;\n}\n\n// ‚úÖ Template literal types for type safety\ntype EventName = `on${\"Click\" | \"Hover\" | \"Focus\"}`;\n// Result: \"onClick\" | \"onHover\" | \"onFocus\"\n\ninterface EventHandlers {\n  onClick: () => void;\n  onHover: () => void;\n  onFocus: () => void;\n}\n\n// ‚úÖ String manipulation in type system\ntype Uppercase<T extends string> = Intrinsic; // Built-in\ntype ID = \"user\" | \"post\";\ntype UpperID = Uppercase<ID>; // \"USER\" | \"POST\"\n```",
      "explanation": "Understanding these distinctions is crucial: **lowercase `string` for types**, **template literals for runtime string building**, and **template literal types for advanced type patterns**. Never use uppercase `String` in TypeScript."
    },
    {
      "id": "interview-001-01-010",
      "question": "How do you properly type check for null and undefined at runtime?",
      "answer": "## Runtime Type Checking for null/undefined\n\n### 1. Strict Equality Check (Recommended)\n\n```typescript\nfunction processValue(value: string | null | undefined) {\n  // Check for null specifically\n  if (value === null) {\n    console.log(\"Value is null\");\n  }\n  \n  // Check for undefined specifically\n  if (value === undefined) {\n    console.log(\"Value is undefined\");\n  }\n  \n  // Check for both\n  if (value === null || value === undefined) {\n    console.log(\"Value is nullish\");\n  }\n}\n```\n\n### 2. Nullish Check (!= null)\n\n```typescript\n// Check for both null and undefined\nfunction process(value: string | null | undefined) {\n  // Using != (loose equality) checks both null and undefined\n  if (value != null) {\n    // value is string here\n    console.log(value.toUpperCase());\n  }\n}\n\n// Equivalent to:\nif (value !== null && value !== undefined) {\n  console.log(value.toUpperCase());\n}\n```\n\n### 3. Type Guards\n\n```typescript\n// Custom type guard for non-null\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\n// Custom type guard for defined\nfunction isDefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n\n// Custom type guard for non-nullish\nfunction isPresent<T>(value: T | null | undefined): value is T {\n  return value != null;\n}\n\n// Usage\nlet value: string | null = getValue();\nif (isNotNull(value)) {\n  // TypeScript knows value is string\n  console.log(value.length);\n}\n```\n\n### 4. Truthy/Falsy Check (Be Careful!)\n\n```typescript\nfunction process(value: string | null | undefined) {\n  // ‚ö†Ô∏è Also checks for empty string!\n  if (value) {\n    console.log(value.toUpperCase());\n  }\n}\n\n// Problems:\nprocess(\"\");        // Skipped! (empty string is falsy)\nprocess(null);      // Skipped\nprocess(undefined); // Skipped\n\n// Better for numbers:\nfunction processNumber(num: number | null | undefined) {\n  // ‚ö†Ô∏è Also checks for 0!\n  if (num) {\n    console.log(num * 2);\n  }\n}\n\nprocessNumber(0);   // Skipped! (0 is falsy)\n```\n\n### 5. typeof Check\n\n```typescript\nfunction process(value: string | null | undefined) {\n  // Check if it's a string\n  if (typeof value === \"string\") {\n    console.log(value.toUpperCase());\n  }\n  \n  // Check for undefined\n  if (typeof value === \"undefined\") {\n    console.log(\"Value is undefined\");\n  }\n  \n  // ‚ö†Ô∏è typeof null is \"object\" (JavaScript quirk!)\n  if (typeof value === \"object\" && value === null) {\n    console.log(\"Value is null\");\n  }\n}\n```\n\n### 6. Optional Chaining + Nullish Coalescing\n\n```typescript\ninterface User {\n  name?: string;\n  address?: {\n    street?: string;\n  };\n}\n\nconst user: User | null = getUser();\n\n// Safe access\nconst street = user?.address?.street ?? \"Unknown\";\n\n// Equivalent to:\nlet street: string;\nif (user !== null && user !== undefined) {\n  if (user.address !== null && user.address !== undefined) {\n    if (user.address.street !== null && user.address.street !== undefined) {\n      street = user.address.street;\n    } else {\n      street = \"Unknown\";\n    }\n  } else {\n    street = \"Unknown\";\n  }\n} else {\n  street = \"Unknown\";\n}\n```\n\n### 7. Array Filter for Non-Null Values\n\n```typescript\n// Remove null/undefined from arrays\nconst values: (string | null | undefined)[] = [\"a\", null, \"b\", undefined, \"c\"];\n\n// Method 1: Type guard\nconst filtered1 = values.filter(isPresent); // string[]\n\n// Method 2: Inline type guard\nconst filtered2 = values.filter((v): v is string => v != null);\n\n// Method 3: Boolean filter (removes all falsy)\nconst filtered3 = values.filter(Boolean); // Won't work with empty strings!\n\n// Method 4: Explicit check\nconst filtered4 = values.filter(v => v !== null && v !== undefined);\n```\n\n### Common Patterns\n\n```typescript\n// Pattern 1: Early return\nfunction processUser(user: User | null) {\n  if (user === null) {\n    return; // or throw error\n  }\n  // user is User here\n  console.log(user.name);\n}\n\n// Pattern 2: Default value\nfunction greet(name: string | null | undefined) {\n  const safeName = name ?? \"Guest\";\n  console.log(`Hello, ${safeName}`);\n}\n\n// Pattern 3: Assertion function\nfunction assertDefined<T>(value: T | null | undefined): asserts value is T {\n  if (value === null || value === undefined) {\n    throw new Error(\"Value is null or undefined\");\n  }\n}\n\nlet value: string | null = getValue();\nassertDefined(value);\n// TypeScript knows value is string after this line\nconsole.log(value.length);\n```\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use strict equality for explicit checks\nif (value === null) { }\nif (value === undefined) { }\n\n// ‚úÖ DO: Use != null for nullish check\nif (value != null) { } // Checks both null and undefined\n\n// ‚úÖ DO: Use optional chaining\nconst result = obj?.prop?.nested;\n\n// ‚ùå DON'T: Use truthy check when 0, \"\", false are valid\nif (count) { } // Wrong if count can be 0\n\n// ‚úÖ DO: Be explicit\nif (count != null) { } // Correct\n\n// ‚ùå DON'T: Use typeof for null\nif (typeof value === \"null\") { } // WRONG! Returns \"object\"\n\n// ‚úÖ DO: Use === null\nif (value === null) { } // Correct\n```",
      "explanation": "Proper runtime null checking is **essential for type safety**. Use strict equality for explicit checks, `!= null` for nullish checks, and avoid truthy checks when falsy values are valid. Optional chaining makes code cleaner and safer."
    },
    {
      "id": "interview-001-01-011",
      "question": "What is the difference between declaring a variable with explicit undefined vs optional?",
      "answer": "## undefined vs Optional\n\n### 1. Optional Property (?)\n\n```typescript\ninterface User {\n  name: string;\n  email?: string;  // Optional: can be string | undefined, or omitted\n}\n\n// Both valid:\nconst user1: User = { name: \"Alice\" };  // email not provided\nconst user2: User = { name: \"Bob\", email: undefined };  // explicit undefined\nconst user3: User = { name: \"Charlie\", email: \"c@example.com\" };  // string\n\n// Property may not exist\nconsole.log(user1.email); // undefined\nconsole.log(\"email\" in user1); // false ‚ùó\n```\n\n### 2. Explicit undefined Type\n\n```typescript\ninterface User {\n  name: string;\n  email: string | undefined;  // Must be provided, can be undefined\n}\n\n// Must provide email property\nconst user1: User = { name: \"Alice\" };  // ‚ùå Error: Property 'email' is missing\nconst user2: User = { name: \"Bob\", email: undefined };  // ‚úÖ OK\nconst user3: User = { name: \"Charlie\", email: \"c@example.com\" };  // ‚úÖ OK\n\n// Property always exists\nconsole.log(\"email\" in user2); // true ‚úÖ\n```\n\n### 3. Key Differences\n\n```typescript\ninterface Optional {\n  prop?: string;\n}\n\ninterface Explicit {\n  prop: string | undefined;\n}\n\n// Object structure\nconst opt1: Optional = {};  // ‚úÖ Valid\nconst opt2: Optional = { prop: undefined };  // ‚úÖ Valid\n\nconst exp1: Explicit = {};  // ‚ùå Error: 'prop' is missing\nconst exp2: Explicit = { prop: undefined };  // ‚úÖ Valid\n\n// Checking existence\nconst optObj: Optional = {};\nconsole.log(optObj.prop);           // undefined\nconsole.log(\"prop\" in optObj);      // false\nconsole.log(optObj.hasOwnProperty(\"prop\")); // false\n\nconst expObj: Explicit = { prop: undefined };\nconsole.log(expObj.prop);           // undefined  \nconsole.log(\"prop\" in expObj);      // true ‚ùó\nconsole.log(expObj.hasOwnProperty(\"prop\")); // true ‚ùó\n```\n\n### 4. Function Parameters\n\n```typescript\n// Optional parameter\nfunction greet1(name?: string) {\n  // name is string | undefined\n  console.log(name ?? \"Guest\");\n}\n\ngreet1();           // ‚úÖ OK - name is undefined\ngreet1(\"Alice\");    // ‚úÖ OK\ngreet1(undefined);  // ‚úÖ OK\n\n// Explicit undefined\nfunction greet2(name: string | undefined) {\n  console.log(name ?? \"Guest\");\n}\n\ngreet2();           // ‚ùå Error: Expected 1 argument\ngreet2(\"Alice\");    // ‚úÖ OK\ngreet2(undefined);  // ‚úÖ OK - must pass explicitly\n```\n\n### 5. Destructuring Behavior\n\n```typescript\ninterface Config {\n  timeout?: number;\n  retries: number | undefined;\n}\n\nconst config: Config = {\n  // timeout omitted\n  retries: undefined  // must provide\n};\n\n// Destructuring with defaults\nconst { timeout = 5000, retries = 3 } = config;\n\nconsole.log(timeout);  // 5000 (default applied)\nconsole.log(retries);  // undefined (default NOT applied!) ‚ùó\n\n// Why? Property exists with value undefined\n```\n\n### 6. exactOptionalPropertyTypes Flag\n\n```typescript\n// With exactOptionalPropertyTypes: true in tsconfig\ninterface User {\n  name: string;\n  email?: string;\n}\n\n// More strict behavior\nconst user1: User = { \n  name: \"Alice\",\n  email: undefined  // ‚ùå Error with exactOptionalPropertyTypes!\n};\n\nconst user2: User = { \n  name: \"Alice\"\n  // ‚úÖ OK - property omitted\n};\n\n// Optional really means \"can be omitted\", not \"can be undefined\"\n```\n\n### 7. Practical Use Cases\n\n```typescript\n// Use optional (?) when:\n// - Property may not be provided\n// - Represents truly optional data\ninterface Product {\n  id: number;\n  name: string;\n  description?: string;  // Not all products have descriptions\n}\n\n// Use explicit undefined when:\n// - Property must be considered/addressed\n// - Represents a nullable value that's always checked\ninterface FormData {\n  firstName: string;\n  lastName: string;\n  middleName: string | undefined;  // Explicitly no middle name vs provided\n}\n\n// Checking the difference\nfunction processProduct(product: Product) {\n  // Need to check if property exists\n  if (\"description\" in product) {\n    console.log(product.description);  // string | undefined\n  }\n}\n\nfunction processForm(data: FormData) {\n  // Property always exists, just check value\n  if (data.middleName !== undefined) {\n    console.log(data.middleName);  // string\n  }\n}\n```\n\n### Comparison Table\n\n| Feature | Optional (?) | Explicit undefined |\n|---------|--------------|-------------------|\n| Property required | No | Yes |\n| Can omit in object | ‚úÖ Yes | ‚ùå No |\n| Can set to undefined | ‚úÖ Yes | ‚úÖ Yes |\n| `in` operator | false if omitted | true |\n| Type | `T \\| undefined` | `T \\| undefined` |\n| Destructure default | ‚úÖ Applied | ‚ùå Not applied |\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use optional for truly optional properties\ninterface User {\n  id: number;\n  name: string;\n  avatar?: string;  // May not have avatar\n}\n\n// ‚úÖ DO: Use explicit undefined for nullable but required properties\ninterface SearchParams {\n  query: string;\n  category: string | undefined;  // Must specify, can be null search\n}\n\n// ‚ùå DON'T: Mix optional and undefined unnecessarily\ninterface Bad {\n  prop?: string | undefined;  // Redundant!\n}\n\n// ‚úÖ DO: Just use optional\ninterface Good {\n  prop?: string;\n}\n```",
      "explanation": "This is a **subtle but important distinction**. Optional (`?`) means the property can be omitted entirely, while explicit `undefined` means the property must exist but can have undefined value. The `in` operator and destructuring behave differently for each."
    },
    {
      "id": "interview-001-01-012",
      "question": "What are literal types and how do they work with basic types in TypeScript?",
      "answer": "## Literal Types\n\n### What are Literal Types?\n\nLiteral types are **exact values** rather than general types. They represent a specific string, number, or boolean value.\n\n### 1. String Literal Types\n\n```typescript\n// String literal type\nlet direction: \"north\" | \"south\" | \"east\" | \"west\";\n\ndirection = \"north\";  // ‚úÖ OK\ndirection = \"up\";     // ‚ùå Error: not in the union\n\n// Function with string literal return\nfunction getStatus(): \"success\" | \"error\" | \"pending\" {\n  return \"success\";\n}\n\n// Type alias for string literals\ntype HttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\nfunction request(method: HttpMethod, url: string) {\n  // method can only be one of the four values\n}\n\nrequest(\"GET\", \"/api\");    // ‚úÖ OK\nrequest(\"PATCH\", \"/api\");  // ‚ùå Error\n```\n\n### 2. Numeric Literal Types\n\n```typescript\n// Numeric literal type\nlet statusCode: 200 | 404 | 500;\n\nstatusCode = 200;  // ‚úÖ OK\nstatusCode = 201;  // ‚ùå Error\n\n// Common use case: configuration\ntype Port = 3000 | 8080 | 9000;\n\ninterface Config {\n  port: Port;\n  timeout: 5000 | 10000 | 30000;\n}\n\nconst config: Config = {\n  port: 3000,\n  timeout: 5000\n};\n\n// Dice roll\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction rollDice(): DiceRoll {\n  return Math.floor(Math.random() * 6) + 1 as DiceRoll;\n}\n```\n\n### 3. Boolean Literal Types\n\n```typescript\n// Boolean literal types\nlet isTrue: true = true;     // Can only be true\nlet isFalse: false = false;  // Can only be false\n\nisTrue = false;  // ‚ùå Error\n\n// Practical use: discriminated unions\ntype SuccessResponse = {\n  success: true;  // Literal type\n  data: string;\n};\n\ntype ErrorResponse = {\n  success: false;  // Literal type\n  error: string;\n};\n\ntype Response = SuccessResponse | ErrorResponse;\n\nfunction handleResponse(response: Response) {\n  if (response.success) {\n    // TypeScript knows this is SuccessResponse\n    console.log(response.data);\n  } else {\n    // TypeScript knows this is ErrorResponse\n    console.log(response.error);\n  }\n}\n```\n\n### 4. Const Declarations Create Literal Types\n\n```typescript\n// const creates literal types\nconst name = \"Alice\";   // type: \"Alice\" (not string)\nconst age = 30;         // type: 30 (not number)\nconst active = true;    // type: true (not boolean)\n\n// let creates general types\nlet name2 = \"Alice\";    // type: string\nlet age2 = 30;          // type: number\nlet active2 = true;     // type: boolean\n\n// Why? const cannot be reassigned\nconst x = \"hello\";\n// x = \"world\";  // ‚ùå Can't reassign const\n\nlet y = \"hello\";\ny = \"world\";  // ‚úÖ Can reassign let, needs general type\n```\n\n### 5. Object Literal Types with as const\n\n```typescript\n// Without as const\nconst config = {\n  host: \"localhost\",  // type: string\n  port: 3000,         // type: number\n  secure: false       // type: boolean\n};\n\n// With as const - creates literal types\nconst config2 = {\n  host: \"localhost\",  // type: \"localhost\"\n  port: 3000,         // type: 3000\n  secure: false       // type: false\n} as const;\n\n// Also makes it readonly\nconfig2.port = 8080;  // ‚ùå Error: readonly property\n\n// Array with as const\nconst colors = [\"red\", \"blue\"] as const;\n// type: readonly [\"red\", \"blue\"] (tuple with literals)\n\nconst colors2 = [\"red\", \"blue\"];\n// type: string[] (array of strings)\n```\n\n### 6. Template Literal Types (Advanced)\n\n```typescript\n// Combine literal types with template strings\ntype Greeting = `Hello, ${\"Alice\" | \"Bob\" | \"Charlie\"}`;\n// Result: \"Hello, Alice\" | \"Hello, Bob\" | \"Hello, Charlie\"\n\nlet greet: Greeting = \"Hello, Alice\";  // ‚úÖ OK\nlet greet2: Greeting = \"Hello, David\"; // ‚ùå Error\n\n// With type parameters\ntype Color = \"red\" | \"blue\" | \"green\";\ntype CSSClass = `text-${Color}` | `bg-${Color}`;\n// Result: \"text-red\" | \"text-blue\" | \"text-green\" | \n//         \"bg-red\" | \"bg-blue\" | \"bg-green\"\n\nlet className: CSSClass = \"text-red\";  // ‚úÖ OK\nlet className2: CSSClass = \"text-yellow\"; // ‚ùå Error\n```\n\n### 7. Literal Types in Function Overloads\n\n```typescript\n// Function overloads with literal types\nfunction createElement(tag: \"a\"): HTMLAnchorElement;\nfunction createElement(tag: \"div\"): HTMLDivElement;\nfunction createElement(tag: \"span\"): HTMLSpanElement;\nfunction createElement(tag: string): HTMLElement {\n  return document.createElement(tag);\n}\n\nconst anchor = createElement(\"a\");    // HTMLAnchorElement\nconst div = createElement(\"div\");     // HTMLDivElement\nconst span = createElement(\"span\");   // HTMLSpanElement\n```\n\n### 8. Exhaustiveness Checking with Literals\n\n```typescript\ntype Status = \"idle\" | \"loading\" | \"success\" | \"error\";\n\nfunction handleStatus(status: Status) {\n  switch (status) {\n    case \"idle\":\n      return \"Not started\";\n    case \"loading\":\n      return \"Loading...\";\n    case \"success\":\n      return \"Done!\";\n    case \"error\":\n      return \"Failed!\";\n    default:\n      // status is never here (all cases handled)\n      const exhaustive: never = status;\n      throw new Error(`Unhandled status: ${exhaustive}`);\n  }\n}\n\n// If you add a new status, TypeScript will error in the default case\n```\n\n### 9. Literal Types vs Enums\n\n```typescript\n// Literal union type\ntype Direction = \"North\" | \"South\" | \"East\" | \"West\";\n\nfunction move(direction: Direction) {\n  console.log(`Moving ${direction}`);\n}\n\nmove(\"North\");  // ‚úÖ OK - plain string\n\n// Enum\nenum DirectionEnum {\n  North = \"North\",\n  South = \"South\",\n  East = \"East\",\n  West = \"West\"\n}\n\nfunction move2(direction: DirectionEnum) {\n  console.log(`Moving ${direction}`);\n}\n\nmove2(DirectionEnum.North);  // Requires enum member\n\n// Literal types are simpler, enums provide namespacing\n```\n\n### 10. Practical Use Cases\n\n```typescript\n// HTTP Status Codes\ntype HttpStatus = 200 | 201 | 400 | 401 | 403 | 404 | 500;\n\ninterface ApiResponse {\n  status: HttpStatus;\n  data?: any;\n}\n\n// Event Names\ntype EventName = \"click\" | \"hover\" | \"focus\" | \"blur\";\n\nfunction addEventListener(event: EventName, handler: () => void) {\n  // Only accepts specific event names\n}\n\n// Configuration Options\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\ntype Environment = \"development\" | \"staging\" | \"production\";\n\ninterface Config {\n  env: Environment;\n  logLevel: LogLevel;\n  port: 3000 | 8080;\n}\n\n// API Methods\ntype CrudOperation = \"create\" | \"read\" | \"update\" | \"delete\";\n\nfunction performOperation(op: CrudOperation, data: any) {\n  // Restricted to CRUD operations\n}\n```\n\n### 11. Combining Literal and General Types\n\n```typescript\n// Mix literal and general types\ntype ID = string | number;\ntype Status = \"active\" | \"inactive\" | number;  // number for custom codes\n\n// Exclude specific literals\ntype NonZeroNumber = number & { __brand: \"NonZero\" };  // Advanced technique\n\n// More practical\ntype PositiveNumber = number;  // Convention: use validation\nfunction isPositive(n: number): n is PositiveNumber {\n  return n > 0;\n}\n```\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use literal types for fixed values\ntype Theme = \"light\" | \"dark\";\n\n// ‚úÖ DO: Use as const for object literals\nconst routes = {\n  home: \"/\",\n  about: \"/about\"\n} as const;\n\n// ‚úÖ DO: Combine with exhaustiveness checking\nfunction handle(status: \"success\" | \"error\") {\n  switch (status) {\n    case \"success\": return \"OK\";\n    case \"error\": return \"Failed\";\n    default: \n      const _: never = status;\n      throw new Error(`Unhandled: ${_}`);\n  }\n}\n\n// ‚ùå DON'T: Overuse literal types\ntype TooSpecific = \"user_123\" | \"user_456\" | \"user_789\";  // Too specific\n\n// ‚úÖ DO: Use general types with validation\ntype UserId = string;  // Better\n\n// ‚ùå DON'T: Mix incompatible literals\ntype Bad = \"success\" | 200 | true;  // Confusing\n\n// ‚úÖ DO: Group related literals\ntype Status = \"success\" | \"error\" | \"pending\";\ntype Code = 200 | 404 | 500;\n```",
      "explanation": "Literal types provide **precise type checking** for specific values. They're excellent for configuration, API responses, and discriminated unions. Using `as const` and template literal types makes TypeScript's type system even more powerful."
    },
    {
      "id": "interview-001-01-013",
      "question": "How do you handle type assertions with basic types and when should you use them?",
      "answer": "## Type Assertions\n\n### What are Type Assertions?\n\nType assertions tell TypeScript **\"trust me, I know the type better than you do\"**. They don't perform any runtime checking or conversion.\n\n### 1. Basic Syntax\n\n```typescript\n// Two syntaxes (both identical)\nlet value: unknown = \"hello\";\n\n// Angle bracket syntax\nlet length1 = (<string>value).length;\n\n// 'as' syntax (preferred, works in JSX)\nlet length2 = (value as string).length;\n\n// Both do the same thing at compile time, nothing at runtime\n```\n\n### 2. Asserting from unknown/any\n\n```typescript\n// From unknown\nlet data: unknown = getApiResponse();\n\n// Need to assert before using\nlet name = (data as { name: string }).name;\n\n// Better: validate first, then assert\nfunction isUser(value: unknown): value is { name: string } {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"name\" in value &&\n    typeof (value as any).name === \"string\"\n  );\n}\n\nif (isUser(data)) {\n  // Type guard is safer than assertion\n  let name = data.name;\n}\n```\n\n### 3. Asserting to More Specific Types\n\n```typescript\n// From general to specific\nlet value: string | number = \"hello\";\n\n// Assert to string\nlet upper = (value as string).toUpperCase();\n// ‚ö†Ô∏è Dangerous if value is actually a number!\n\n// Better approach - use type guard\nif (typeof value === \"string\") {\n  let upper = value.toUpperCase();  // Safe\n}\n```\n\n### 4. const Assertions\n\n```typescript\n// Regular literal\nlet x = \"hello\";  // type: string\n\n// const assertion\nlet y = \"hello\" as const;  // type: \"hello\"\n\n// Object with const assertion\nlet config = {\n  host: \"localhost\",\n  port: 3000\n} as const;\n// type: { readonly host: \"localhost\"; readonly port: 3000; }\n\n// Array with const assertion\nlet colors = [\"red\", \"blue\"] as const;\n// type: readonly [\"red\", \"blue\"]\n\n// Benefits:\n// 1. Creates literal types\n// 2. Makes everything readonly\n// 3. Prevents accidental mutations\n```\n\n### 5. Non-null Assertion (!)\n\n```typescript\n// Non-null assertion operator\nlet name: string | null = getName();\n\n// Without assertion\nif (name !== null) {\n  console.log(name.length);\n}\n\n// With assertion (tells TS \"it's not null\")\nconsole.log(name!.length);  // ‚ö†Ô∏è Dangerous!\n\n// When to use: when you're 100% sure it's not null\nlet element = document.getElementById(\"app\")!;\n// You know it exists in the DOM\n\n// Better: handle the null case\nlet element2 = document.getElementById(\"app\");\nif (element2) {\n  element2.innerHTML = \"Hello\";\n}\n```\n\n### 6. Double Assertions (Escape Hatch)\n\n```typescript\n// Sometimes TypeScript won't allow direct assertion\nlet num: number = 42;\n\n// This fails\n// let str: string = num as string;  // ‚ùå Error\n\n// Double assertion (escape hatch)\nlet str: string = num as unknown as string;  // ‚úÖ Compiles\n// First: number ‚Üí unknown (always allowed)\n// Second: unknown ‚Üí string (allowed from unknown)\n\n// ‚ö†Ô∏è VERY DANGEROUS - bypasses type safety completely\n// Only use when you absolutely know what you're doing\n```\n\n### 7. When to Use Type Assertions\n\n```typescript\n// ‚úÖ GOOD: After runtime validation\nfunction processInput(input: unknown) {\n  if (typeof input === \"string\" && input.includes(\"@\")) {\n    // We've validated it's a string with @\n    let email = input as string;  // Safe assertion\n    return email.toLowerCase();\n  }\n}\n\n// ‚úÖ GOOD: DOM elements\nlet input = document.getElementById(\"email\") as HTMLInputElement;\nlet value = input.value;  // We know it's an input element\n\n// ‚úÖ GOOD: Type narrowing not working\ntype Circle = { kind: \"circle\"; radius: number };\ntype Square = { kind: \"square\"; size: number };\ntype Shape = Circle | Square;\n\nfunction getArea(shape: Shape) {\n  // Sometimes TS doesn't narrow correctly\n  if (shape.kind === \"circle\") {\n    return Math.PI * (shape as Circle).radius ** 2;\n  }\n}\n\n// ‚ùå BAD: Avoiding proper typing\nfunction add(a: any, b: any) {\n  return (a as number) + (b as number);  // Wrong!\n}\n\n// ‚úÖ GOOD: Proper typing\nfunction add(a: number, b: number) {\n  return a + b;  // No assertion needed\n}\n```\n\n### 8. Assertions vs Type Guards\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\n// Using assertion (unsafe)\nfunction getUserName1(data: unknown): string {\n  return (data as User).name;  // ‚ö†Ô∏è Crashes if data isn't User\n}\n\n// Using type guard (safe)\nfunction isUser(data: unknown): data is User {\n  return (\n    typeof data === \"object\" &&\n    data !== null &&\n    \"name\" in data &&\n    \"age\" in data &&\n    typeof (data as any).name === \"string\" &&\n    typeof (data as any).age === \"number\"\n  );\n}\n\nfunction getUserName2(data: unknown): string | null {\n  if (isUser(data)) {\n    return data.name;  // Safe - validated\n  }\n  return null;\n}\n```\n\n### 9. Common Pitfalls\n\n```typescript\n// Pitfall 1: Asserting wrong type\nlet value: string | number = 42;\nlet upper = (value as string).toUpperCase();  // üí• Runtime error!\n\n// Pitfall 2: Ignoring type system\nfunction process(input: any) {\n  let str = input as string;  // No safety\n  return str.toUpperCase();   // Might crash\n}\n\n// Pitfall 3: Over-using non-null assertion\nfunction findUser(id: string) {\n  let user = users.find(u => u.id === id)!;  // ‚ö†Ô∏è What if not found?\n  return user.name;  // üí• Crashes if user is undefined\n}\n\n// Better\nfunction findUser2(id: string) {\n  let user = users.find(u => u.id === id);\n  if (!user) {\n    throw new Error(`User ${id} not found`);\n  }\n  return user.name;  // Safe\n}\n```\n\n### 10. Safe Assertion Patterns\n\n```typescript\n// Pattern 1: Validate then assert\nfunction parseNumber(value: unknown): number {\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const num = Number(value);\n    if (!isNaN(num)) {\n      return num;\n    }\n  }\n  throw new Error(\"Cannot parse as number\");\n}\n\n// Pattern 2: Assertion function\nfunction assertString(value: unknown): asserts value is string {\n  if (typeof value !== \"string\") {\n    throw new Error(\"Expected string\");\n  }\n}\n\nlet data: unknown = getUserInput();\nassertString(data);\n// TypeScript knows data is string after this line\nlet upper = data.toUpperCase();\n\n// Pattern 3: Safe optional chaining with assertion\nlet config: unknown = getConfig();\nlet port = (config as any)?.port ?? 3000;  // Default value\n```\n\n### 11. as const vs Regular Assertions\n\n```typescript\n// Regular assertion\nlet status = \"success\" as string;  // type: string\n\n// as const assertion\nlet status2 = \"success\" as const;  // type: \"success\" (literal)\n\n// Difference\nlet config1 = { mode: \"dev\" };  // { mode: string }\nlet config2 = { mode: \"dev\" } as const;  // { readonly mode: \"dev\" }\n\nconfig1.mode = \"prod\";  // ‚úÖ OK\nconfig2.mode = \"prod\";  // ‚ùå Error: readonly\n```\n\n### Best Practices\n\n```typescript\n// ‚úÖ DO: Use as const for literal types\nconst config = { api: \"https://api.example.com\" } as const;\n\n// ‚úÖ DO: Validate before asserting\nif (typeof value === \"string\") {\n  process(value as string);\n}\n\n// ‚úÖ DO: Use type guards instead of assertions\nfunction isString(v: unknown): v is string {\n  return typeof v === \"string\";\n}\n\n// ‚úÖ DO: Use assertion functions for validation\nfunction assertNumber(v: unknown): asserts v is number {\n  if (typeof v !== \"number\") throw new Error(\"Not a number\");\n}\n\n// ‚ùå DON'T: Assert without validation\nlet name = (unknownData as User).name;  // Dangerous!\n\n// ‚ùå DON'T: Use double assertions unless absolutely necessary\nlet x = value as unknown as SomeType;  // Code smell\n\n// ‚ùå DON'T: Overuse non-null assertion\nlet user = getUser()!;  // What if null?\n\n// ‚úÖ DO: Handle null case\nlet user = getUser();\nif (user) {\n  // Use user safely\n}\n```",
      "explanation": "Type assertions are a **powerful escape hatch** but can bypass TypeScript's safety. Use them sparingly and only after runtime validation. Prefer type guards and assertion functions over raw assertions. Remember: assertions don't perform runtime checks!"
    }
  ]
}
