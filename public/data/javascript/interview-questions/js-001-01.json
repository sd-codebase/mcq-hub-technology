{
  "interview_questions": [
    {
      "id": "interview-001-01-001",
      "question": "What are the main differences between var, let, and const?",
      "answer": "## Main Differences\n\nThe main differences are:\n\n### 1. **Scope**\n- `var` is **function-scoped**\n- `let` and `const` are **block-scoped**\n\n```javascript\nfunction test() {\n  if (true) {\n    var x = 1;  // Function-scoped\n    let y = 2;  // Block-scoped\n  }\n  console.log(x); // 1 (accessible)\n  console.log(y); // ReferenceError\n}\n```\n\n### 2. **Hoisting**\n- All three are hoisted\n- `var` is initialized with `undefined`\n- `let` and `const` remain in the **Temporal Dead Zone** until declaration\n\n### 3. **Redeclaration**\n- `var` allows redeclaration in the same scope\n- `let` and `const` don't allow redeclaration\n\n### 4. **Reassignment**\n- `var` and `let` allow reassignment\n- `const` doesn't allow reassignment\n\n### 5. **Initialization**\n- `var` and `let` can be declared without initialization\n- `const` must be initialized at declaration",
      "explanation": "Understanding these differences is **crucial** for writing modern JavaScript. `const` should be your default choice, followed by `let` when reassignment is needed. `var` should generally be avoided in modern code due to its confusing scoping rules."
    },
    {
      "id": "interview-001-01-002",
      "question": "What is the Temporal Dead Zone (TDZ)?",
      "answer": "## Temporal Dead Zone (TDZ)\n\nThe **Temporal Dead Zone** is the period between entering a scope and the actual declaration line of `let` or `const` variables. During this time, the variable exists (is hoisted) but cannot be accessed.\n\n### Example\n```javascript\nconsole.log(x); // ReferenceError: Cannot access 'x' before initialization\nlet x = 5; // TDZ ends here\n```\n\n### Why TDZ Exists\n1. **Catch programming errors** - prevents using variables before they're properly declared\n2. **Make const truly constant** - prevents access before initialization\n3. **Better scoping semantics** - clearer than var's undefined behavior\n\n### Visual Representation\n```javascript\n{ // TDZ starts for 'value'\n  // TDZ continues\n  // TDZ continues\n  console.log(value); // ReferenceError (in TDZ)\n  let value = 10; // TDZ ends\n  console.log(value); // 10 (safe to use)\n}\n```\n\n### Key Points\n- Only applies to `let` and `const`, not `var`\n- Accessing variable in TDZ throws `ReferenceError`\n- TDZ is temporal (time-based), not spatial (location-based)",
      "explanation": "The TDZ helps prevent bugs by ensuring variables are only accessed after they're properly declared. This is a **key improvement** over `var`'s behavior where undefined access was silently allowed."
    },
    {
      "id": "interview-001-01-003",
      "question": "Why is const not truly immutable?",
      "answer": "## Const is NOT Immutable\n\n`const` creates an **immutable binding** (the variable name cannot be reassigned), but **not an immutable value**.\n\n### For Objects and Arrays\n\n```javascript\n// Properties can be modified\nconst obj = { name: 'John' };\nobj.name = 'Jane'; // ‚úÖ Allowed - modifying property\nobj = {}; // ‚ùå TypeError - reassigning variable\n\n// Array elements can be modified\nconst arr = [1, 2, 3];\narr.push(4); // ‚úÖ Allowed - modifying array\narr[0] = 99; // ‚úÖ Allowed - changing element\narr = []; // ‚ùå TypeError - reassigning variable\n```\n\n### What Const Actually Does\n\n```javascript\nconst reference = { value: 1 };\n// 'reference' always points to the same object\n// But the object itself can change\n```\n\n### Achieving True Immutability\n\n**1. Object.freeze()** (shallow)\n```javascript\nconst obj = Object.freeze({ name: 'John' });\nobj.name = 'Jane'; // Fails silently (strict mode: TypeError)\n```\n\n**2. Deep freeze** (recursive)\n```javascript\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.values(obj).forEach(val => {\n    if (typeof val === 'object' && val !== null) {\n      deepFreeze(val);\n    }\n  });\n  return obj;\n}\n```\n\n**3. Immutable libraries**\n- Immutable.js\n- Immer",
      "explanation": "This is a **common source of confusion**. `const` protects the variable reference, not the value itself. Understanding this distinction is important for proper JavaScript programming and avoiding bugs."
    },
    {
      "id": "interview-001-01-004",
      "question": "Explain hoisting with var, let, and const.",
      "answer": "## Hoisting in JavaScript\n\nHoisting moves **declarations** to the top of their scope during compilation, but initialization behavior differs:\n\n### var - Hoisted and Initialized\n\n```javascript\nconsole.log(x); // undefined (not an error!)\nvar x = 5;\n\n// Interpreted as:\nvar x; // Declaration hoisted and initialized to undefined\nconsole.log(x); // undefined\nx = 5; // Assignment stays in place\n```\n\n### let/const - Hoisted but NOT Initialized (TDZ)\n\n```javascript\nconsole.log(y); // ReferenceError: Cannot access 'y' before initialization\nlet y = 5;\n\n// Interpreted as:\n// let y; (hoisted but in TDZ)\nconsole.log(y); // ReferenceError - in TDZ!\nlet y = 5; // Declaration and initialization\n```\n\n### Function Hoisting\n\n```javascript\n// Function declarations are fully hoisted\nsayHello(); // Works!\n\nfunction sayHello() {\n  console.log('Hello');\n}\n\n// Function expressions are NOT fully hoisted\nsayBye(); // TypeError: sayBye is not a function\n\nvar sayBye = function() {\n  console.log('Bye');\n};\n```\n\n### Key Differences\n\n| Feature | var | let/const |\n|---------|-----|----------|\n| Hoisted? | ‚úÖ Yes | ‚úÖ Yes |\n| Initialized? | ‚úÖ undefined | ‚ùå TDZ |\n| Accessible before declaration? | ‚úÖ Yes (undefined) | ‚ùå ReferenceError |",
      "explanation": "Hoisting is a **compilation phase behavior**, not a runtime behavior. Understanding it helps debug confusing errors and write cleaner code. Remember: **declarations are hoisted, initializations are not**."
    },
    {
      "id": "interview-001-01-005",
      "question": "What problems does var have that let and const solve?",
      "answer": "## Problems with var\n\n### 1. **No Block Scope** - Leaks out of blocks\n\n```javascript\nif (true) {\n  var x = 1;\n}\nconsole.log(x); // 1 - leaked out! üò±\n\n// With let:\nif (true) {\n  let y = 2;\n}\nconsole.log(y); // ReferenceError - properly scoped ‚úÖ\n```\n\n### 2. **Classic Loop Variable Problem**\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Output: 3, 3, 3 üò±\n\n// With let:\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Output: 0, 1, 2 ‚úÖ\n```\n\n### 3. **Accidental Globals**\n\n```javascript\nfunction test() {\n  forgotten = 10; // Creates global without var!\n}\ntest();\nconsole.log(window.forgotten); // 10 üò±\n```\n\n### 4. **Confusing Hoisting**\n\n```javascript\nconsole.log(x); // undefined (weird!)\nvar x = 5;\n\n// vs\nconsole.log(y); // ReferenceError (clear error!)\nlet y = 5;\n```\n\n### 5. **Can Redeclare**\n\n```javascript\nvar name = 'John';\nvar name = 'Jane'; // No error üò±\nconsole.log(name); // 'Jane'\n\n// With let:\nlet name = 'John';\nlet name = 'Jane'; // SyntaxError ‚úÖ\n```\n\n## How let/const Solve These\n\n‚úÖ **Block scoping** - variables stay where they belong  \n‚úÖ **TDZ** - catch errors early  \n‚úÖ **No redeclaration** - prevent accidental overwrites  \n‚úÖ **Stricter rules** - fewer surprises",
      "explanation": "These problems made JavaScript code **error-prone and hard to debug**. `let` and `const` were introduced in ES6 to provide more predictable scoping behavior. Always prefer them over `var` in modern code."
    },
    {
      "id": "interview-001-01-006",
      "question": "When should you use const vs let?",
      "answer": "## Best Practice Hierarchy\n\n### 1. **Default to `const`** ü•á\n\nUse for any value that won't be reassigned:\n\n```javascript\nconst MAX_USERS = 100;\nconst API_URL = 'https://api.example.com';\nconst user = { name: 'John', age: 30 };\nconst calculateTotal = (items) => { /* ... */ };\n```\n\n**Benefits:**\n- ‚úÖ Prevents accidental reassignment\n- ‚úÖ Signals intent to other developers\n- ‚úÖ Easier to reason about code\n- ‚úÖ Catches bugs early\n\n### 2. **Use `let` only when necessary** ü•à\n\nWhen you need to reassign:\n\n```javascript\n// Loop counters\nfor (let i = 0; i < 10; i++) { }\n\n// Accumulator variables\nlet total = 0;\nitems.forEach(item => total += item.price);\n\n// Conditional assignments\nlet message;\nif (isError) {\n  message = 'Error occurred';\n} else {\n  message = 'Success';\n}\n\n// Values that change over time\nlet currentUser = null;\nlogin().then(user => currentUser = user);\n```\n\n### 3. **Never use `var`** üö´\n\nUnless maintaining legacy code:\n\n```javascript\n// ‚ùå Don't do this\nvar x = 10;\n\n// ‚úÖ Do this instead\nconst x = 10;\n// or\nlet x = 10;\n```\n\n### Decision Tree\n\n```\nNeed to declare a variable?\n  |\n  ‚îú‚îÄ Will it be reassigned?\n  ‚îÇ   |\n  ‚îÇ   ‚îú‚îÄ No ‚Üí Use const ‚úÖ\n  ‚îÇ   ‚îî‚îÄ Yes ‚Üí Use let ‚úÖ\n  ‚îÇ\n  ‚îî‚îÄ Using var? ‚Üí Refactor to let/const ‚úÖ\n```\n\n### Real-World Example\n\n```javascript\n// ‚úÖ Good practice\nconst users = [];\nconst fetchUsers = async () => {\n  const response = await fetch('/api/users');\n  const data = await response.json();\n  return data;\n};\n\nlet currentPage = 1;\nconst nextPage = () => {\n  currentPage++; // Reassignment needed\n  fetchUsers();\n};\n```",
      "explanation": "**Const by default** is a widely adopted convention in modern JavaScript. It makes code more maintainable and predictable by making immutability the default and mutation the exception."
    },
    {
      "id": "interview-001-01-007",
      "question": "Explain variable shadowing with let, const, and var.",
      "answer": "## Variable Shadowing\n\nShadowing occurs when a variable in an **inner scope** has the same name as one in an **outer scope**.\n\n### let/const (Block-scoped Shadowing) ‚úÖ\n\n```javascript\nlet x = 1;\nconsole.log(x); // 1\n\n{\n  let x = 2; // Different variable, shadows outer x\n  console.log(x); // 2 (inner x)\n  \n  {\n    let x = 3; // Another different variable\n    console.log(x); // 3 (innermost x)\n  }\n  \n  console.log(x); // 2 (back to middle x)\n}\n\nconsole.log(x); // 1 (back to outer x)\n```\n\n### var (Function-scoped, No Block Shadowing) ‚ö†Ô∏è\n\n```javascript\nvar y = 1;\nconsole.log(y); // 1\n\n{\n  var y = 2; // Same variable, redeclares!\n  console.log(y); // 2\n}\n\nconsole.log(y); // 2 - overwritten! üò±\n```\n\n### Function Scope Shadowing (Works with all)\n\n```javascript\nlet z = 1;\n\nfunction test() {\n  let z = 2; // Different variable in function scope\n  console.log(z); // 2\n}\n\ntest();\nconsole.log(z); // 1\n```\n\n### Practical Example\n\n```javascript\nconst config = { theme: 'dark' };\n\nfunction processData(data) {\n  // Shadow with different meaning in function scope\n  const config = { maxItems: 10 };\n  console.log(config.maxItems); // 10\n}\n\nprocessData([]);\nconsole.log(config.theme); // 'dark'\n```\n\n### Common Pitfall with var\n\n```javascript\nvar name = 'Global';\n\nif (true) {\n  var name = 'Block'; // Overwrites global!\n}\n\nconsole.log(name); // 'Block' üò±\n\n// With let:\nlet name2 = 'Global';\n\nif (true) {\n  let name2 = 'Block'; // Separate variable\n}\n\nconsole.log(name2); // 'Global' ‚úÖ\n```\n\n### Best Practices\n\n‚úÖ Use shadowing intentionally for clear scope separation  \n‚úÖ Prefer `let`/`const` for predictable shadowing  \n‚ùå Avoid `var` to prevent accidental overwrites  \n‚ö†Ô∏è Be careful with parameter names shadowing outer variables",
      "explanation": "Understanding shadowing helps **prevent bugs** and write clearer code. `let` and `const`'s block scoping makes shadowing **intentional and limited** in scope, unlike `var`'s unpredictable behavior."
    },
    {
      "id": "interview-001-01-008",
      "question": "What happens when you declare a variable without var, let, or const?",
      "answer": "## Declaring Without var/let/const\n\n### In Non-Strict Mode ‚ö†Ô∏è\n\nCreates an **implicit global variable**:\n\n```javascript\nfunction test() {\n  x = 10; // No declaration keyword!\n}\n\ntest();\nconsole.log(x); // 10 (global!)\nconsole.log(window.x); // 10 (browser)\n```\n\n### In Strict Mode ‚úÖ\n\nThrows a **ReferenceError**:\n\n```javascript\n'use strict';\n\nfunction test() {\n  x = 10; // ReferenceError: x is not defined\n}\n\ntest(); // Error!\n```\n\n### Why This is Dangerous\n\n**1. Global Pollution**\n```javascript\nfunction calculateTotal() {\n  total = 0; // Oops, forgot let!\n  // ...\n}\n\n// Later in code:\nfunction calculateAverage() {\n  total = 0; // Same global variable!\n}\n\n// Both functions interfere with each other! üò±\n```\n\n**2. Hard to Debug**\n```javascript\nfunction deepFunction() {\n  result = 42; // Creates global\n}\n\n// 1000 lines later...\nconsole.log(result); // Where did this come from? ü§î\n```\n\n**3. Naming Conflicts**\n```javascript\n// Your code\nfunction init() {\n  data = { name: 'John' };\n}\n\n// Third-party library also uses 'data'\n// Conflict! üí•\n```\n\n### How It Works\n\n```javascript\n// Without strict mode:\nx = 5;\n\n// Equivalent to:\nwindow.x = 5; // (in browser)\n// or\nglobal.x = 5; // (in Node.js)\n```\n\n### Best Practices\n\n‚úÖ **Always use `'use strict';`** at the top of files/functions  \n‚úÖ **Always use explicit declarations** (`const`, `let`)  \n‚úÖ **Use a linter** (ESLint) to catch these errors  \n‚ùå **Never rely on implicit globals**\n\n### Quick Fix\n\n```javascript\n// ‚ùå Bad\nfunction calculate() {\n  sum = 0;\n  for (i = 0; i < 10; i++) {\n    sum += i;\n  }\n}\n\n// ‚úÖ Good\nfunction calculate() {\n  let sum = 0;\n  for (let i = 0; i < 10; i++) {\n    sum += i;\n  }\n}\n```",
      "explanation": "This is a **common source of bugs** in JavaScript. Strict mode helps catch these errors. Modern JavaScript development should **always use explicit variable declarations** and strict mode."
    },
    {
      "id": "interview-001-01-009",
      "question": "Can you explain the classic var loop problem and how let fixes it?",
      "answer": "## The Classic var Loop Problem\n\n### The Problem üò±\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n\n// Expected: 0, 1, 2\n// Actual: 3, 3, 3 üò±\n```\n\n### Why Does This Happen?\n\n**1. var is function-scoped, not block-scoped**\n```javascript\n// What actually happens:\nvar i; // Only ONE variable for entire loop\n\nfor (i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Loop finishes, i = 3\n// Then all callbacks execute and see i = 3\n```\n\n**2. Closures capture the variable, not the value**\n```javascript\nfor (var i = 0; i < 3; i++) {\n  // Each callback references the SAME 'i' variable\n  setTimeout(() => console.log(i), 100);\n}\n// By the time callbacks run, i = 3\n```\n\n### Visual Representation\n\n```javascript\n// var creates one variable:\nvar i;\n\ni = 0: setTimeout(callback1) // callback1 references i\ni = 1: setTimeout(callback2) // callback2 references i (same variable)\ni = 2: setTimeout(callback3) // callback3 references i (same variable)\ni = 3: loop ends\n\n// All callbacks see i = 3\n```\n\n### Solution 1: Use let ‚úÖ\n\n```javascript\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n\n// Output: 0, 1, 2 ‚úÖ\n```\n\n**Why let works:**\n- Creates a **new binding** for each iteration\n- Each callback captures its own `i`\n\n```javascript\n// let creates separate variables:\nIteration 0: let i = 0; setTimeout(callback1) // captures i=0\nIteration 1: let i = 1; setTimeout(callback2) // captures i=1\nIteration 2: let i = 2; setTimeout(callback3) // captures i=2\n```\n\n### Solution 2: IIFE (Old Way)\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  (function(j) {\n    setTimeout(() => console.log(j), 100);\n  })(i);\n}\n\n// Output: 0, 1, 2\n// But verbose and harder to read! üòì\n```\n\n### Solution 3: forEach\n\n```javascript\n[0, 1, 2].forEach(i => {\n  setTimeout(() => console.log(i), 100);\n});\n\n// Output: 0, 1, 2\n// Each callback gets its own 'i' parameter\n```\n\n### Real-World Example\n\n```javascript\n// ‚ùå Problem: Creating event listeners in a loop\nconst buttons = document.querySelectorAll('button');\n\nfor (var i = 0; i < buttons.length; i++) {\n  buttons[i].addEventListener('click', () => {\n    console.log('Button ' + i); // Always logs last index!\n  });\n}\n\n// ‚úÖ Solution with let:\nfor (let i = 0; i < buttons.length; i++) {\n  buttons[i].addEventListener('click', () => {\n    console.log('Button ' + i); // Logs correct index!\n  });\n}\n```\n\n### Key Takeaway\n\n| Feature | var | let |\n|---------|-----|-----|\n| Scope | Function | Block |\n| Loop behavior | Shares variable | New binding per iteration |\n| Closure capture | Reference to shared variable | Reference to unique variable |",
      "explanation": "This was a **notorious JavaScript gotcha** that confused many developers. `let`'s block scoping creates a **fresh binding per iteration**, solving the closure problem elegantly. This is one of the primary reasons to use `let` instead of `var`."
    },
    {
      "id": "interview-001-01-010",
      "question": "How do you achieve true immutability in JavaScript?",
      "answer": "## Achieving True Immutability\n\n`const` alone **doesn't provide immutability** for objects/arrays. Here are several approaches:\n\n### 1. Object.freeze() (Shallow) ‚ùÑÔ∏è\n\n```javascript\nconst obj = Object.freeze({ name: 'John', age: 30 });\n\nobj.name = 'Jane'; // Fails silently (non-strict)\nobj.age = 25;      // Fails silently (non-strict)\n\n// In strict mode:\n'use strict';\nobj.name = 'Jane'; // TypeError ‚úÖ\n\nconsole.log(obj); // { name: 'John', age: 30 }\n```\n\n**Limitation - Shallow only:**\n```javascript\nconst obj = Object.freeze({\n  name: 'John',\n  address: { city: 'NYC' }\n});\n\nobj.name = 'Jane'; // ‚ùå Fails (frozen)\nobj.address.city = 'LA'; // ‚úÖ Works! (nested object not frozen)\n```\n\n### 2. Deep Freeze (Recursive) üßä\n\n```javascript\nfunction deepFreeze(obj) {\n  // Freeze the object itself\n  Object.freeze(obj);\n  \n  // Recursively freeze all properties\n  Object.values(obj).forEach(val => {\n    if (typeof val === 'object' && val !== null) {\n      deepFreeze(val);\n    }\n  });\n  \n  return obj;\n}\n\n// Usage:\nconst person = deepFreeze({\n  name: 'John',\n  address: {\n    city: 'NYC',\n    zip: '10001'\n  }\n});\n\nperson.address.city = 'LA'; // ‚ùå Fails completely\n```\n\n### 3. Spread Operator (Creates New Copy) üìã\n\n```javascript\nconst original = { name: 'John', age: 30 };\n\n// Create new object with changes\nconst updated = { ...original, age: 31 };\n\nconsole.log(original); // { name: 'John', age: 30 } unchanged\nconsole.log(updated);  // { name: 'John', age: 31 } new object\n```\n\n**For arrays:**\n```javascript\nconst original = [1, 2, 3];\nconst updated = [...original, 4];\n\nconsole.log(original); // [1, 2, 3] unchanged\nconsole.log(updated);  // [1, 2, 3, 4] new array\n```\n\n### 4. Immutable Libraries üìö\n\n**Immutable.js:**\n```javascript\nimport { Map } from 'immutable';\n\nconst map1 = Map({ name: 'John', age: 30 });\nconst map2 = map1.set('age', 31);\n\nconsole.log(map1.get('age')); // 30 (unchanged)\nconsole.log(map2.get('age')); // 31 (new map)\n```\n\n**Immer:**\n```javascript\nimport produce from 'immer';\n\nconst original = { name: 'John', age: 30 };\n\nconst updated = produce(original, draft => {\n  draft.age = 31; // Feels like mutation\n});\n\nconsole.log(original); // { name: 'John', age: 30 } unchanged\nconsole.log(updated);  // { name: 'John', age: 31 } new object\n```\n\n### 5. Immutable Array Methods üîÑ\n\n```javascript\nconst original = [1, 2, 3];\n\n// ‚úÖ Returns new arrays (immutable):\nconst mapped = original.map(x => x * 2);\nconst filtered = original.filter(x => x > 1);\nconst sliced = original.slice(1);\nconst concatenated = original.concat([4, 5]);\n\n// ‚ùå Mutates original:\noriginal.push(4);      // Mutates!\noriginal.sort();       // Mutates!\noriginal.reverse();    // Mutates!\n```\n\n### 6. Object.seal() vs Object.freeze() üîí\n\n```javascript\n// freeze: Can't add, delete, or modify\nconst frozen = Object.freeze({ name: 'John' });\nfrozen.name = 'Jane';  // ‚ùå Fails\nfrozen.age = 30;       // ‚ùå Fails\ndelete frozen.name;    // ‚ùå Fails\n\n// seal: Can't add or delete, but CAN modify\nconst sealed = Object.seal({ name: 'John' });\nsealed.name = 'Jane';  // ‚úÖ Works!\nsealed.age = 30;       // ‚ùå Fails\ndelete sealed.name;    // ‚ùå Fails\n```\n\n### Comparison Table\n\n| Method | Level | Pros | Cons |\n|--------|-------|------|------|\n| `const` | Variable reference | Simple | Doesn't protect object contents |\n| `Object.freeze()` | Shallow | Built-in, fast | Only shallow |\n| `deepFreeze()` | Deep | Complete protection | Performance cost |\n| Spread | Copy | Simple, clear | Must remember to use |\n| Libraries | Deep | Optimized, full features | Additional dependency |\n\n### Best Practices\n\n```javascript\n// ‚úÖ Prefer immutable operations\nconst addItem = (arr, item) => [...arr, item];\nconst updateProp = (obj, key, val) => ({ ...obj, [key]: val });\n\n// ‚ùå Avoid mutations\nconst addItem = (arr, item) => {\n  arr.push(item); // Mutates!\n  return arr;\n};\n```",
      "explanation": "True immutability requires **additional techniques beyond `const`**. This is important for **functional programming** and state management in frameworks like **React** and **Redux**. Choose the right approach based on your needs: `Object.freeze()` for simple cases, deep freeze for nested structures, or libraries for complex applications."
    }
  ]
}
