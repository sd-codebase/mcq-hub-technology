{
  "interview_questions": [
    {
      "id": "interview-001-02-001",
      "question": "What are the primitive data types in JavaScript?",
      "answer": "## The 7 Primitive Data Types\n\nJavaScript has **7 primitive data types**:\n\n### 1. **String** üìù\nText data enclosed in quotes:\n```javascript\nlet name = 'John';\nlet greeting = \"Hello\";\nlet template = `Hello, ${name}`; // Template literal\n```\n\n### 2. **Number** üî¢\nNumeric values including integers and floats:\n```javascript\nlet integer = 42;\nlet float = 3.14;\nlet negative = -10;\nlet special = NaN;        // Not a Number\nlet infinite = Infinity;  // Infinite value\n```\n\n### 3. **BigInt** üî¢‚ûï\nLarge integers beyond safe integer limit:\n```javascript\nlet big = 123456789012345678901234567890n;\nlet bigInt = BigInt(\"9007199254740991\");\n// Useful for: cryptography, timestamps, large IDs\n```\n\n### 4. **Boolean** ‚úÖ‚ùå\nLogical values:\n```javascript\nlet isActive = true;\nlet hasError = false;\n```\n\n### 5. **Undefined** ‚ùì\nUninitialized or missing values:\n```javascript\nlet x;              // undefined\nlet obj = {};\nobj.missing;        // undefined\nfunction noReturn() {}\nnoReturn();         // undefined\n```\n\n### 6. **Null** ‚≠ï\nIntentional absence of value:\n```javascript\nlet empty = null;   // Explicitly set to \"no value\"\n```\n\n### 7. **Symbol** üîë\nUnique identifiers:\n```javascript\nlet sym1 = Symbol('description');\nlet sym2 = Symbol('description');\nsym1 === sym2;  // false (always unique)\n\n// Use cases: unique object keys, private properties\n```\n\n## Reference Types üì¶\n\nAll other types are **reference types** (objects):\n- Objects: `{}`\n- Arrays: `[]`\n- Functions: `function() {}`\n- Dates: `new Date()`\n- RegExp: `/pattern/`\n- etc.\n\n## Quick Comparison Table\n\n| Type | Example | Mutable | typeof Result |\n|------|---------|---------|---------------|\n| String | `'hello'` | ‚ùå No | `'string'` |\n| Number | `42` | ‚ùå No | `'number'` |\n| BigInt | `42n` | ‚ùå No | `'bigint'` |\n| Boolean | `true` | ‚ùå No | `'boolean'` |\n| Undefined | `undefined` | ‚ùå No | `'undefined'` |\n| Null | `null` | ‚ùå No | `'object'` ‚ö†Ô∏è |\n| Symbol | `Symbol()` | ‚ùå No | `'symbol'` |",
      "explanation": "Primitives are **immutable** and stored **by value**. They represent simple single values, unlike objects which can contain multiple values and methods. Understanding primitive types is fundamental to JavaScript programming."
    },
    {
      "id": "interview-001-02-002",
      "question": "Explain the difference between primitive and reference types with examples.",
      "answer": "## Primitive vs Reference Types\n\n### **Storage & Copying** üíæ\n\n#### Primitives (Stored by Value)\n```javascript\nlet a = 5;\nlet b = a;     // Copy of value\nb = 10;\n\nconsole.log(a); // 5 - unchanged ‚úÖ\nconsole.log(b); // 10\n\n// What happens in memory:\n// a ‚Üí 5 (original location)\n// b ‚Üí 5 (different location with copied value)\n```\n\n#### Reference Types (Stored by Reference)\n```javascript\nlet obj1 = { x: 5 };\nlet obj2 = obj1;  // Copy of reference\nobj2.x = 10;\n\nconsole.log(obj1.x); // 10 - changed! ‚ö†Ô∏è\nconsole.log(obj2.x); // 10\n\n// What happens in memory:\n// obj1 ‚Üí 0x001 (memory address)\n// obj2 ‚Üí 0x001 (same memory address)\n// 0x001: { x: 5 } ‚Üí { x: 10 }\n```\n\n### **Comparison** ‚öñÔ∏è\n\n#### Primitives (Value Comparison)\n```javascript\nlet str1 = 'hello';\nlet str2 = 'hello';\n\nconsole.log(str1 === str2); // true ‚úÖ\n// Compares actual values\n```\n\n#### Reference Types (Reference Comparison)\n```javascript\nlet arr1 = [1, 2, 3];\nlet arr2 = [1, 2, 3];\nlet arr3 = arr1;\n\nconsole.log(arr1 === arr2); // false ‚ùå (different objects)\nconsole.log(arr1 === arr3); // true ‚úÖ (same object)\n\n// Even though arr1 and arr2 have identical content,\n// they're different objects in memory\n```\n\n### **Mutability** üîí\n\n#### Primitives (Immutable)\n```javascript\nlet str = 'hello';\nstr[0] = 'H';           // Fails silently\nstr.toUpperCase();      // Returns new string\n\nconsole.log(str);        // 'hello' - unchanged\n\n// You can't modify primitives, only reassign:\nstr = 'HELLO';           // Reassignment creates new value\n```\n\n#### Reference Types (Mutable)\n```javascript\nconst obj = { name: 'John' };\nobj.name = 'Jane';      // Modifies object ‚úÖ\nobj.age = 30;           // Adds property ‚úÖ\n\nconsole.log(obj);       // { name: 'Jane', age: 30 }\n\nconst arr = [1, 2, 3];\narr.push(4);            // Modifies array ‚úÖ\narr[0] = 99;            // Changes element ‚úÖ\n```\n\n### **Memory Location** üó∫Ô∏è\n\n#### Primitives (Stack)\n```javascript\n// Stored directly in stack (fast access)\nlet num = 42;\nlet str = 'hello';\nlet bool = true;\n```\n\n#### Reference Types (Heap)\n```javascript\n// Reference in stack, object in heap\nlet obj = { x: 1 };  // obj (stack) ‚Üí { x: 1 } (heap)\nlet arr = [1, 2, 3]; // arr (stack) ‚Üí [1,2,3] (heap)\n```\n\n### **Function Parameters** üì§\n\n#### Primitives (Pass by Value)\n```javascript\nfunction changeValue(x) {\n  x = 100;  // Only changes local copy\n}\n\nlet num = 5;\nchangeValue(num);\nconsole.log(num); // 5 - unchanged ‚úÖ\n```\n\n#### Reference Types (Pass by Reference)\n```javascript\nfunction changeObject(obj) {\n  obj.x = 100;  // Modifies original! ‚ö†Ô∏è\n}\n\nlet myObj = { x: 5 };\nchangeObject(myObj);\nconsole.log(myObj.x); // 100 - changed!\n\n// However, reassignment doesn't affect original:\nfunction reassign(obj) {\n  obj = { x: 100 };  // Only changes local reference\n}\n\nlet myObj2 = { x: 5 };\nreassign(myObj2);\nconsole.log(myObj2.x); // 5 - unchanged ‚úÖ\n```\n\n## Summary Table\n\n| Feature | Primitive | Reference |\n|---------|-----------|----------|\n| **Stored** | By value | By reference |\n| **Location** | Stack | Heap (reference in stack) |\n| **Copied** | Value copied | Reference copied |\n| **Comparison** | Value | Reference (memory address) |\n| **Mutable** | ‚ùå No | ‚úÖ Yes |\n| **Passed to function** | Copy of value | Copy of reference |\n| **Examples** | `5`, `'hello'`, `true` | `{}`, `[]`, `function(){}` |",
      "explanation": "Understanding this distinction is **crucial** for predicting behavior when passing values to functions, copying data, and comparing values. Most bugs in JavaScript stem from not understanding the difference between value and reference semantics."
    },
    {
      "id": "interview-001-02-003",
      "question": "Why does typeof null return 'object'? Is null an object?",
      "answer": "## The typeof null Bug üêõ\n\n### The Short Answer\n\n**No, null is NOT an object** - it's a primitive type. `typeof null === 'object'` is a **bug** in JavaScript that has existed since the beginning and is kept for **backward compatibility**.\n\n### The Historical Reason üìú\n\nIn JavaScript's first implementation:\n\n```javascript\n// Internal representation (simplified):\n// Values were represented with a type tag + value\n\n// Type tags (first 3 bits):\n// 000: object\n// 001: integer\n// 010: double\n// 100: string\n// 110: boolean\n\n// null was represented as:\n// NULL pointer (0x00) = all zeros\n// Which matches object's type tag (000)\n// Therefore: typeof null === 'object' ‚ùå\n```\n\n### Why It Wasn't Fixed üîß\n\nFixing this would **break millions of websites**:\n\n```javascript\n// Lots of legacy code relies on this:\nif (typeof value === 'object' && value !== null) {\n  // Handle object\n}\n\n// If typeof null changed to 'null',\n// this code would break everywhere!\n```\n\n### The Correct Way to Check for null ‚úÖ\n\n```javascript\nlet x = null;\n\n// ‚úÖ Method 1: Direct comparison\nconsole.log(x === null);  // true\n\n// ‚úÖ Method 2: Loose equality with undefined\nconsole.log(x == null);   // true\nconsole.log(x == undefined); // true (only null/undefined)\n\n// ‚úÖ Method 3: Object.prototype.toString\nconsole.log(Object.prototype.toString.call(x)); // '[object Null]'\n\n// ‚ùå Don't rely on typeof:\nconsole.log(typeof x);    // 'object' (misleading!)\n```\n\n### Checking for Objects (Excluding null) üéØ\n\n```javascript\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\nconsole.log(isObject({}));        // true ‚úÖ\nconsole.log(isObject([]));        // true ‚úÖ\nconsole.log(isObject(null));      // false ‚úÖ\nconsole.log(isObject('string'));  // false ‚úÖ\n```\n\n### Real-World Impact üíº\n\n```javascript\n// Common mistake:\nfunction processData(data) {\n  if (typeof data === 'object') {\n    // This runs for null too! ‚ö†Ô∏è\n    data.property; // TypeError if data is null!\n  }\n}\n\n// Correct version:\nfunction processData(data) {\n  if (typeof data === 'object' && data !== null) {\n    // Safe to access properties ‚úÖ\n    data.property;\n  }\n}\n```\n\n### typeof Results for All Types üìä\n\n```javascript\nconsole.log(typeof undefined);       // 'undefined' ‚úÖ\nconsole.log(typeof null);            // 'object' ‚ùå BUG!\nconsole.log(typeof true);            // 'boolean' ‚úÖ\nconsole.log(typeof 42);              // 'number' ‚úÖ\nconsole.log(typeof 42n);             // 'bigint' ‚úÖ\nconsole.log(typeof 'hello');         // 'string' ‚úÖ\nconsole.log(typeof Symbol());        // 'symbol' ‚úÖ\nconsole.log(typeof {});              // 'object' ‚úÖ\nconsole.log(typeof []);              // 'object' ‚úÖ\nconsole.log(typeof function(){});    // 'function' ‚úÖ\n```\n\n### Key Takeaways üéì\n\n1. **null is a primitive**, not an object\n2. `typeof null === 'object'` is a **known bug**\n3. **Always add** `&& value !== null` when checking for objects\n4. Use **direct comparison** (`=== null`) to check for null\n5. This bug will **never be fixed** due to backward compatibility",
      "explanation": "This is one of JavaScript's **most famous quirks**. Despite `typeof`'s result, null is officially a primitive type representing **intentional absence of value**. Every JavaScript developer should know this gotcha and how to work around it."
    },
    {
      "id": "interview-001-02-004",
      "question": "What is autoboxing in JavaScript? Provide examples.",
      "answer": "## Autoboxing in JavaScript üì¶\n\n### What is Autoboxing?\n\n**Autoboxing** is JavaScript's automatic temporary wrapping of primitive values in their corresponding **object wrappers** to access methods.\n\n### How It Works üîÑ\n\n```javascript\nlet str = 'hello';          // Primitive string\nlet upper = str.toUpperCase(); // Method call on primitive?\n\n// Behind the scenes:\n// 1. JavaScript creates: new String('hello')\n// 2. Calls method: temp.toUpperCase()\n// 3. Returns result: 'HELLO'\n// 4. Discards temp object\n// 5. str remains a primitive\n\nconsole.log(typeof str);    // 'string' (still primitive!)\n```\n\n### The Process Step-by-Step üë£\n\n```javascript\n// What you write:\n'hello'.toUpperCase();\n\n// What JavaScript does:\n(function() {\n  let temp = new String('hello'); // 1. Create wrapper\n  let result = temp.toUpperCase(); // 2. Call method\n  temp = null;                     // 3. Discard wrapper\n  return result;                   // 4. Return result\n})();\n```\n\n### All Primitive Wrappers üéÅ\n\n```javascript\n// String wrapper\nlet str = 'hello';\nstr.toUpperCase();              // Autoboxed to String\nstr.length;                     // Autoboxed to String\n\n// Number wrapper\nlet num = 42;\nnum.toFixed(2);                 // Autoboxed to Number\nnum.toString();                 // Autoboxed to Number\n\n// Boolean wrapper\nlet bool = true;\nbool.toString();                // Autoboxed to Boolean\n\n// Symbol wrapper\nlet sym = Symbol('test');\nsym.toString();                 // Autoboxed to Symbol\n\n// BigInt wrapper\nlet big = 123n;\nbig.toString();                 // Autoboxed to BigInt\n```\n\n### Exceptions: No Autoboxing ‚ùå\n\n```javascript\n// null and undefined have NO wrappers:\nnull.toString();      // TypeError ‚ùå\nundefined.toString(); // TypeError ‚ùå\n\n// They cannot access methods\n```\n\n### Autoboxing vs Explicit Wrapping üÜö\n\n```javascript\n// ‚úÖ Autoboxing (automatic, temporary):\nlet str1 = 'hello';\nconsole.log(str1.toUpperCase());  // 'HELLO'\nconsole.log(typeof str1);         // 'string' (still primitive)\n\n// ‚ùå Explicit wrapping (permanent object):\nlet str2 = new String('hello');\nconsole.log(str2.toUpperCase());  // 'HELLO'\nconsole.log(typeof str2);         // 'object' (now an object!)\n\n// Comparison issues:\nlet str3 = 'hello';\nlet str4 = new String('hello');\nconsole.log(str3 === str4);       // false ‚ùå\nconsole.log(str3 == str4);        // true (coerced)\n```\n\n### Adding Properties to Primitives ü§î\n\n```javascript\n// This doesn't work as you might expect:\nlet str = 'hello';\nstr.customProperty = 'value';\n\nconsole.log(str.customProperty); // undefined ‚ùå\n\n// Why? The wrapper is temporary:\n// 1. new String(str).customProperty = 'value'\n// 2. Wrapper discarded immediately\n// 3. Next access creates NEW wrapper without property\n\n// With explicit wrapper:\nlet strObj = new String('hello');\nstrObj.customProperty = 'value';\nconsole.log(strObj.customProperty); // 'value' ‚úÖ\n```\n\n### Performance Implications ‚ö°\n\n```javascript\n// Autoboxing has negligible performance cost\n// (optimized by JavaScript engines)\n\nlet str = 'hello';\nfor (let i = 0; i < 1000000; i++) {\n  str.toUpperCase(); // Autoboxing happens 1M times\n  // Modern engines optimize this away\n}\n\n// Explicit wrapping is slower and uses more memory:\nlet strObj = new String('hello');\nfor (let i = 0; i < 1000000; i++) {\n  strObj.toUpperCase(); // Object method call\n  // No optimization possible\n}\n```\n\n### Real-World Examples üåç\n\n```javascript\n// String methods:\n'hello'.charAt(0);              // 'h'\n'hello'.split('');              // ['h','e','l','l','o']\n'hello'.substring(0, 2);        // 'he'\n\n// Number methods:\n(42).toFixed(2);                // '42.00'\n(42).toExponential();           // '4.2e+1'\n(42).toPrecision(4);            // '42.00'\n\n// Array-like behavior on strings:\n'hello'[0];                     // 'h' (autoboxing)\n'hello'.length;                 // 5 (autoboxing)\n\n// Method chaining:\n'  hello  '\n  .trim()                       // Autobox\n  .toUpperCase()                // Autobox\n  .split('')                    // Autobox\n  .reverse()                    // Array method\n  .join('');                    // Array method\n  // Result: 'OLLEH'\n```\n\n### Best Practices üìù\n\n```javascript\n// ‚úÖ DO: Use primitives and let autoboxing happen\nlet str = 'hello';\nstr.toUpperCase();\n\n// ‚ùå DON'T: Create wrapper objects explicitly\nlet str = new String('hello'); // Unnecessary and confusing\n\n// ‚úÖ DO: Use wrapper constructors for type conversion (without 'new')\nlet num = Number('42');         // 42 (primitive)\nlet str = String(123);          // '123' (primitive)\nlet bool = Boolean(1);          // true (primitive)\n\n// ‚ùå DON'T: Use wrappers with 'new' for type conversion\nlet num = new Number('42');     // Number object ‚ùå\n```",
      "explanation": "Autoboxing makes primitives **feel like objects** by providing access to methods, while maintaining the **performance benefits** of primitives. The wrapper objects are created and destroyed automatically, making this process transparent to developers. Understanding autoboxing helps explain why primitives can have methods despite being immutable values."
    },
    {
      "id": "interview-001-02-005",
      "question": "How do you check if a value is truly an object and not null?",
      "answer": "## Checking for Objects (Excluding null) üîç\n\n### The Problem üö®\n\n```javascript\ntypeof null === 'object'  // true ‚ö†Ô∏è\ntypeof {} === 'object'    // true ‚úÖ\ntypeof [] === 'object'    // true ‚úÖ\n\n// typeof alone isn't enough!\n```\n\n### Method 1: typeof with null Check (Most Common) ‚≠ê\n\n```javascript\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\n// Testing:\nconsole.log(isObject({}));          // true ‚úÖ\nconsole.log(isObject([]));          // true ‚úÖ\nconsole.log(isObject(new Date())); // true ‚úÖ\nconsole.log(isObject(null));        // false ‚úÖ\nconsole.log(isObject('string'));    // false ‚úÖ\nconsole.log(isObject(42));          // false ‚úÖ\nconsole.log(isObject(undefined));   // false ‚úÖ\n```\n\n### Method 2: Object() Constructor Comparison üîÑ\n\n```javascript\nfunction isObject(value) {\n  return value === Object(value) && value !== null;\n}\n\n// How it works:\n// Object(primitive) returns a wrapper object\n// Object(object) returns the same object\n// Only objects satisfy: value === Object(value)\n\nconsole.log(isObject({}));       // true ‚úÖ\nconsole.log(isObject([]));       // true ‚úÖ\nconsole.log(isObject(null));     // false ‚úÖ\nconsole.log(isObject(42));       // false ‚úÖ\n```\n\n### Method 3: Plain Objects Only (Excludes Arrays, Functions, etc.) üìã\n\n```javascript\nfunction isPlainObject(value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\n// Testing:\nconsole.log(isPlainObject({}));            // true ‚úÖ\nconsole.log(isPlainObject({ a: 1 }));     // true ‚úÖ\nconsole.log(isPlainObject([]));            // false ‚ùå\nconsole.log(isPlainObject(new Date()));    // false ‚ùå\nconsole.log(isPlainObject(function(){}));  // false ‚ùå\nconsole.log(isPlainObject(null));          // false ‚úÖ\n```\n\n### Method 4: Constructor Check üèóÔ∏è\n\n```javascript\nfunction isPlainObject(value) {\n  return value?.constructor === Object;\n}\n\n// Testing:\nconsole.log(isPlainObject({}));            // true ‚úÖ\nconsole.log(isPlainObject(Object.create(null))); // false (no constructor)\nconsole.log(isPlainObject([]));            // false ‚ùå\nconsole.log(isPlainObject(new Date()));    // false ‚ùå\nconsole.log(isPlainObject(null));          // false ‚úÖ\n```\n\n### Method 5: Using Object.prototype.toString üè∑Ô∏è\n\n```javascript\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\n// Detects specific types:\nconsole.log(getType({}));          // 'Object'\nconsole.log(getType([]));          // 'Array'\nconsole.log(getType(null));        // 'Null'\nconsole.log(getType(undefined));   // 'Undefined'\nconsole.log(getType(new Date())); // 'Date'\nconsole.log(getType(/regex/));     // 'RegExp'\n\n// Use it:\nfunction isObject(value) {\n  return getType(value) === 'Object';\n}\n```\n\n### Comprehensive Type Checking Utility üõ†Ô∏è\n\n```javascript\nconst TypeChecker = {\n  // Any object (including arrays, dates, etc.)\n  isObject(value) {\n    return typeof value === 'object' && value !== null;\n  },\n  \n  // Plain objects only\n  isPlainObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n  },\n  \n  // Arrays\n  isArray(value) {\n    return Array.isArray(value);\n  },\n  \n  // Functions\n  isFunction(value) {\n    return typeof value === 'function';\n  },\n  \n  // null\n  isNull(value) {\n    return value === null;\n  },\n  \n  // undefined\n  isUndefined(value) {\n    return value === undefined;\n  },\n  \n  // null or undefined\n  isNullish(value) {\n    return value == null;\n  },\n  \n  // Any value (not null/undefined)\n  isValue(value) {\n    return value != null;\n  }\n};\n\n// Usage:\nconsole.log(TypeChecker.isObject({}));        // true\nconsole.log(TypeChecker.isPlainObject([]));   // false\nconsole.log(TypeChecker.isArray([1, 2, 3])); // true\n```\n\n### Common Pitfalls and Edge Cases ‚ö†Ô∏è\n\n```javascript\n// Edge case 1: Object.create(null)\nlet obj = Object.create(null);\nconsole.log(typeof obj);                    // 'object'\nconsole.log(obj === null);                  // false\nconsole.log(obj.constructor === Object);    // false (no constructor!)\n\n// Edge case 2: Arrays are objects\nlet arr = [1, 2, 3];\nconsole.log(typeof arr);                    // 'object'\nconsole.log(arr instanceof Object);         // true\nconsole.log(Array.isArray(arr));           // true (use this!)\n\n// Edge case 3: Functions are objects\nlet fn = function() {};\nconsole.log(typeof fn);                     // 'function' (special case)\nconsole.log(fn instanceof Object);          // true\n\n// Edge case 4: Boxed primitives\nlet numObj = new Number(42);\nconsole.log(typeof numObj);                 // 'object'\nconsole.log(numObj instanceof Number);      // true\nconsole.log(numObj instanceof Object);      // true\n```\n\n### Decision Tree üå≥\n\n```javascript\nfunction whatIsIt(value) {\n  // null/undefined\n  if (value == null) {\n    return value === null ? 'null' : 'undefined';\n  }\n  \n  // Primitives\n  if (typeof value !== 'object' && typeof value !== 'function') {\n    return typeof value; // 'string', 'number', 'boolean', etc.\n  }\n  \n  // Functions\n  if (typeof value === 'function') {\n    return 'function';\n  }\n  \n  // Arrays\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  \n  // Other objects\n  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n}\n\n// Testing:\nconsole.log(whatIsIt(null));           // 'null'\nconsole.log(whatIsIt(undefined));      // 'undefined'\nconsole.log(whatIsIt('hello'));        // 'string'\nconsole.log(whatIsIt(42));             // 'number'\nconsole.log(whatIsIt({}));             // 'object'\nconsole.log(whatIsIt([]));             // 'array'\nconsole.log(whatIsIt(new Date()));     // 'date'\nconsole.log(whatIsIt(/regex/));        // 'regexp'\nconsole.log(whatIsIt(function(){}));   // 'function'\n```\n\n### Best Practices üìù\n\n1. **For any object check**: `typeof value === 'object' && value !== null`\n2. **For plain objects only**: `Object.prototype.toString.call(value) === '[object Object]'`\n3. **For arrays**: `Array.isArray(value)`\n4. **For functions**: `typeof value === 'function'`\n5. **Always account for null** when using `typeof`",
      "explanation": "The **null check is essential** when using `typeof` to detect objects because of JavaScript's historical `typeof null === 'object'` bug. Different methods serve different purposes depending on whether you need to detect **all objects** (including arrays, dates, etc.) or only **plain objects**. Choose the appropriate method based on your specific requirements."
    },
    {
      "id": "interview-001-02-006",
      "question": "What's the difference between null and undefined?",
      "answer": "## null vs undefined üÜö\n\n### Core Difference üéØ\n\n- **undefined**: Represents **uninitialized** or missing values (system-assigned)\n- **null**: Represents **intentional absence** of value (programmer-assigned)\n\n### When undefined Occurs ü§î\n\n```javascript\n// 1. Uninitialized variables\nlet x;\nconsole.log(x); // undefined\n\n// 2. Missing function parameters\nfunction greet(name) {\n  console.log(name); // undefined if not passed\n}\ngreet();\n\n// 3. Missing object properties\nlet obj = { name: 'John' };\nconsole.log(obj.age); // undefined\n\n// 4. Functions without return statement\nfunction noReturn() {\n  let x = 5;\n  // No return\n}\nconsole.log(noReturn()); // undefined\n\n// 5. Array holes (sparse arrays)\nlet arr = [1, , 3];\nconsole.log(arr[1]); // undefined\n\n// 6. void operator\nconsole.log(void 0); // undefined\n```\n\n### When to Use null üìã\n\n```javascript\n// 1. Intentionally empty value\nlet user = null; // No user logged in\n\n// 2. Resetting a value\nlet data = { name: 'John' };\ndata = null; // Clear the data\n\n// 3. API responses\nlet response = {\n  user: null,        // No user found\n  error: null        // No error occurred\n};\n\n// 4. DOM methods\nlet element = document.getElementById('missing');\nconsole.log(element); // null (element not found)\n\n// 5. Placeholder for objects\nlet config = null; // Will be assigned later\n```\n\n### Type Comparison üîç\n\n```javascript\n// typeof\nconsole.log(typeof undefined); // 'undefined' ‚úÖ\nconsole.log(typeof null);      // 'object' ‚ö†Ô∏è (bug!)\n\n// Direct comparison\nconsole.log(undefined === undefined); // true\nconsole.log(null === null);          // true\nconsole.log(undefined === null);     // false (strict)\nconsole.log(undefined == null);      // true (loose) ‚ö†Ô∏è\n\n// Boolean conversion\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(null));      // false\nconsole.log(!undefined);         // true\nconsole.log(!null);              // true\n```\n\n### Checking for null vs undefined ‚úÖ\n\n```javascript\nlet value;\n\n// Check for undefined specifically\nif (value === undefined) {\n  console.log('undefined');\n}\nif (typeof value === 'undefined') {\n  console.log('undefined (safer for undeclared variables)');\n}\n\n// Check for null specifically\nif (value === null) {\n  console.log('null');\n}\n\n// Check for either (nullish)\nif (value == null) {\n  console.log('null or undefined');\n}\nif (value === null || value === undefined) {\n  console.log('null or undefined (explicit)');\n}\n\n// Modern nullish check\nif (value ?? false) {\n  console.log('has value');\n} else {\n  console.log('null or undefined');\n}\n```\n\n### Real-World Scenarios üåç\n\n```javascript\n// Scenario 1: Function parameters\nfunction createUser(name, age) {\n  // undefined = parameter not provided\n  // null = explicitly passed as null\n  \n  if (age === undefined) {\n    age = 18; // Default value\n  }\n  \n  if (age === null) {\n    throw new Error('Age cannot be null');\n  }\n}\n\ncreateUser('John');      // age = 18 (undefined ‚Üí default)\ncreateUser('Jane', 25);  // age = 25\ncreateUser('Bob', null); // Error (explicit null)\n\n// Scenario 2: API responses\nconst fetchUser = async (id) => {\n  const response = await api.get(`/users/${id}`);\n  \n  if (response.status === 404) {\n    return null; // User not found (intentional)\n  }\n  \n  return response.data; // User object or undefined if error\n};\n\n// Scenario 3: Object properties\nlet config = {\n  theme: 'dark',\n  language: undefined, // Not set yet\n  notifications: null  // Explicitly disabled\n};\n\n// Check if property exists\nif ('language' in config) {\n  console.log('language key exists'); // true\n}\nif ('missing' in config) {\n  console.log('missing key exists'); // false\n}\n```\n\n### Common Patterns üé®\n\n```javascript\n// Pattern 1: Default values\nfunction greet(name) {\n  // Old way:\n  name = name !== undefined ? name : 'Guest';\n  \n  // Modern way:\n  name = name ?? 'Guest';\n  \n  // Or with default parameters:\n  // function greet(name = 'Guest')\n}\n\n// Pattern 2: Optional chaining\nlet user = null;\nconsole.log(user?.address?.city); // undefined (safe)\n// vs\n// console.log(user.address.city); // TypeError!\n\n// Pattern 3: Nullish coalescing\nlet value = null;\nlet result = value ?? 'default'; // 'default'\n\nlet value2 = undefined;\nlet result2 = value2 ?? 'default'; // 'default'\n\nlet value3 = 0;\nlet result3 = value3 ?? 'default'; // 0 (not nullish!)\n\n// Pattern 4: Distinguishing absence types\nfunction processValue(value) {\n  if (value === undefined) {\n    return 'Not provided';\n  }\n  if (value === null) {\n    return 'Explicitly empty';\n  }\n  return `Value: ${value}`;\n}\n\nconsole.log(processValue());         // 'Not provided'\nconsole.log(processValue(null));     // 'Explicitly empty'\nconsole.log(processValue('hello'));  // 'Value: hello'\n```\n\n### JSON Behavior üì¶\n\n```javascript\nlet obj = {\n  a: undefined,\n  b: null,\n  c: 'value'\n};\n\nlet json = JSON.stringify(obj);\nconsole.log(json);\n// {\"b\":null,\"c\":\"value\"}\n// undefined is removed! ‚ö†Ô∏è\n\nlet parsed = JSON.parse(json);\nconsole.log(parsed);\n// { b: null, c: 'value' }\n// 'a' property is gone!\n```\n\n### Comparison Table üìä\n\n| Feature | undefined | null |\n|---------|-----------|------|\n| **Meaning** | Uninitialized/missing | Intentionally empty |\n| **Type** | undefined | object (bug) |\n| **typeof** | 'undefined' | 'object' |\n| **Assignment** | Automatic | Manual |\n| **JSON** | Removed | Preserved |\n| **Default param** | Triggers default | Doesn't trigger |\n| **Nullish (`??`)** | Nullish | Nullish |\n| **Falsy** | Yes | Yes |\n| **== null** | true | true |\n| **=== null** | false | true |\n\n### Best Practices üìù\n\n```javascript\n// ‚úÖ DO: Use undefined for uninitialized values\nlet user; // undefined by default\n\n// ‚úÖ DO: Use null for intentional \"no value\"\nlet selectedItem = null; // No item selected\n\n// ‚úÖ DO: Check for nullish values\nif (value == null) {\n  // Handles both undefined and null\n}\n\n// ‚úÖ DO: Use nullish coalescing for defaults\nlet name = userName ?? 'Guest';\n\n// ‚ùå DON'T: Explicitly set undefined\nlet x = undefined; // Just use: let x;\n\n// ‚ùå DON'T: Return undefined explicitly\nfunction getValue() {\n  return undefined; // Just use: return;\n}\n\n// ‚úÖ DO: Use null for \"not found\" or \"empty\"\nfunction findUser(id) {\n  if (!userExists(id)) {\n    return null; // Clear intent: user not found\n  }\n  return user;\n}\n```",
      "explanation": "**undefined** means 'hasn't been assigned' (absence by omission), while **null** means 'intentionally empty' (absence by design). Use **null** when you want to explicitly indicate absence of a value, and let **undefined** occur naturally for uninitialized variables. Understanding this distinction helps write clearer, more intentional code."
    }
  ]
}
