{
  "interview_questions": [
    {
      "id": "interview-001-01-001",
      "question": "What are the main differences between var, let, and const?",
      "answer": "## Main Differences\n\nThe main differences are:\n\n### 1. **Scope**\n- `var` is **function-scoped**\n- `let` and `const` are **block-scoped**\n\n```javascript\nfunction test() {\n  if (true) {\n    var x = 1;  // Function-scoped\n    let y = 2;  // Block-scoped\n  }\n  console.log(x); // 1 (accessible)\n  console.log(y); // ReferenceError\n}\n```\n\n### 2. **Hoisting**\n- All three are hoisted\n- `var` is initialized with `undefined`\n- `let` and `const` remain in the **Temporal Dead Zone** until declaration\n\n### 3. **Redeclaration**\n- `var` allows redeclaration in the same scope\n- `let` and `const` don't allow redeclaration\n\n### 4. **Reassignment**\n- `var` and `let` allow reassignment\n- `const` doesn't allow reassignment\n\n### 5. **Initialization**\n- `var` and `let` can be declared without initialization\n- `const` must be initialized at declaration",
      "explanation": "Understanding these differences is **crucial** for writing modern JavaScript. `const` should be your default choice, followed by `let` when reassignment is needed. `var` should generally be avoided in modern code due to its confusing scoping rules."
    },
    {
      "id": "interview-001-01-002",
      "question": "What is the Temporal Dead Zone (TDZ)?",
      "answer": "## Temporal Dead Zone (TDZ)\n\nThe **Temporal Dead Zone** is the period between entering a scope and the actual declaration line of `let` or `const` variables. During this time, the variable exists (is hoisted) but cannot be accessed.\n\n### Example\n```javascript\nconsole.log(x); // ReferenceError: Cannot access 'x' before initialization\nlet x = 5; // TDZ ends here\n```\n\n### Why TDZ Exists\n1. **Catch programming errors** - prevents using variables before they're properly declared\n2. **Make const truly constant** - prevents access before initialization\n3. **Better scoping semantics** - clearer than var's undefined behavior\n\n### Visual Representation\n```javascript\n{ // TDZ starts for 'value'\n  // TDZ continues\n  // TDZ continues\n  console.log(value); // ReferenceError (in TDZ)\n  let value = 10; // TDZ ends\n  console.log(value); // 10 (safe to use)\n}\n```\n\n### Key Points\n- Only applies to `let` and `const`, not `var`\n- Accessing variable in TDZ throws `ReferenceError`\n- TDZ is temporal (time-based), not spatial (location-based)",
      "explanation": "The TDZ helps prevent bugs by ensuring variables are only accessed after they're properly declared. This is a **key improvement** over `var`'s behavior where undefined access was silently allowed."
    },
    {
      "id": "interview-001-01-003",
      "question": "Why is const not truly immutable?",
      "answer": "## Const is NOT Immutable\n\n`const` creates an **immutable binding** (the variable name cannot be reassigned), but **not an immutable value**.\n\n### For Objects and Arrays\n\n```javascript\n// Properties can be modified\nconst obj = { name: 'John' };\nobj.name = 'Jane'; // ‚úÖ Allowed - modifying property\nobj = {}; // ‚ùå TypeError - reassigning variable\n\n// Array elements can be modified\nconst arr = [1, 2, 3];\narr.push(4); // ‚úÖ Allowed - modifying array\narr[0] = 99; // ‚úÖ Allowed - changing element\narr = []; // ‚ùå TypeError - reassigning variable\n```\n\n### What Const Actually Does\n\n```javascript\nconst reference = { value: 1 };\n// 'reference' always points to the same object\n// But the object itself can change\n```\n\n### Achieving True Immutability\n\n**1. Object.freeze()** (shallow)\n```javascript\nconst obj = Object.freeze({ name: 'John' });\nobj.name = 'Jane'; // Fails silently (strict mode: TypeError)\n```\n\n**2. Deep freeze** (recursive)\n```javascript\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.values(obj).forEach(val => {\n    if (typeof val === 'object' && val !== null) {\n      deepFreeze(val);\n    }\n  });\n  return obj;\n}\n```\n\n**3. Immutable libraries**\n- Immutable.js\n- Immer",
      "explanation": "This is a **common source of confusion**. `const` protects the variable reference, not the value itself. Understanding this distinction is important for proper JavaScript programming and avoiding bugs."
    },
    {
      "id": "interview-001-01-004",
      "question": "Explain hoisting with var, let, and const.",
      "answer": "## Hoisting in JavaScript\n\nHoisting moves **declarations** to the top of their scope during compilation, but initialization behavior differs:\n\n### var - Hoisted and Initialized\n\n```javascript\nconsole.log(x); // undefined (not an error!)\nvar x = 5;\n\n// Interpreted as:\nvar x; // Declaration hoisted and initialized to undefined\nconsole.log(x); // undefined\nx = 5; // Assignment stays in place\n```\n\n### let/const - Hoisted but NOT Initialized (TDZ)\n\n```javascript\nconsole.log(y); // ReferenceError: Cannot access 'y' before initialization\nlet y = 5;\n\n// Interpreted as:\n// let y; (hoisted but in TDZ)\nconsole.log(y); // ReferenceError - in TDZ!\nlet y = 5; // Declaration and initialization\n```\n\n### Function Hoisting\n\n```javascript\n// Function declarations are fully hoisted\nsayHello(); // Works!\n\nfunction sayHello() {\n  console.log('Hello');\n}\n\n// Function expressions are NOT fully hoisted\nsayBye(); // TypeError: sayBye is not a function\n\nvar sayBye = function() {\n  console.log('Bye');\n};\n```\n\n### Key Differences\n\n| Feature | var | let/const |\n|---------|-----|----------|\n| Hoisted? | ‚úÖ Yes | ‚úÖ Yes |\n| Initialized? | ‚úÖ undefined | ‚ùå TDZ |\n| Accessible before declaration? | ‚úÖ Yes (undefined) | ‚ùå ReferenceError |",
      "explanation": "Hoisting is a **compilation phase behavior**, not a runtime behavior. Understanding it helps debug confusing errors and write cleaner code. Remember: **declarations are hoisted, initializations are not**."
    },
    {
      "id": "interview-001-01-005",
      "question": "What problems does var have that let and const solve?",
      "answer": "## Problems with var\n\n### 1. **No Block Scope** - Leaks out of blocks\n\n```javascript\nif (true) {\n  var x = 1;\n}\nconsole.log(x); // 1 - leaked out! üò±\n\n// With let:\nif (true) {\n  let y = 2;\n}\nconsole.log(y); // ReferenceError - properly scoped ‚úÖ\n```\n\n### 2. **Classic Loop Variable Problem**\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Output: 3, 3, 3 üò±\n\n// With let:\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 100);\n}\n// Output: 0, 1, 2 ‚úÖ\n```\n\n### 3. **Accidental Globals**\n\n```javascript\nfunction test() {\n  forgotten = 10; // Creates global without var!\n}\ntest();\nconsole.log(window.forgotten); // 10 üò±\n```\n\n### 4. **Confusing Hoisting**\n\n```javascript\nconsole.log(x); // undefined (weird!)\nvar x = 5;\n\n// vs\nconsole.log(y); // ReferenceError (clear error!)\nlet y = 5;\n```\n\n### 5. **Can Redeclare**\n\n```javascript\nvar name = 'John';\nvar name = 'Jane'; // No error üò±\nconsole.log(name); // 'Jane'\n\n// With let:\nlet name = 'John';\nlet name = 'Jane'; // SyntaxError ‚úÖ\n```\n\n## How let/const Solve These\n\n‚úÖ **Block scoping** - variables stay where they belong  \n‚úÖ **TDZ** - catch errors early  \n‚úÖ **No redeclaration** - prevent accidental overwrites  \n‚úÖ **Stricter rules** - fewer surprises",
      "explanation": "These problems made JavaScript code **error-prone and hard to debug**. `let` and `const` were introduced in ES6 to provide more predictable scoping behavior. Always prefer them over `var` in modern code."
    }
  ]
}
